<doc>
    <assembly>
        <name>gpgme-sharp</name>
    </assembly>
    <members>
        <member name="T:Libgpgme.AlgorithmCapability">
            <summary>A type to determine the algorithm capability.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.AlgorithmCapability.CanAuth">
            <summary>The algorithm has the capability to authenticate.</summary>
        </member>
        <member name="F:Libgpgme.AlgorithmCapability.CanCert">
            <summary>The algorithm has the capability to certify.</summary>
        </member>
        <member name="F:Libgpgme.AlgorithmCapability.CanEncrypt">
            <summary>The algorithm can be used for encryption and decryption.</summary>
        </member>
        <member name="F:Libgpgme.AlgorithmCapability.CanNothing">
            <summary>Invalid value.</summary>
        </member>
        <member name="F:Libgpgme.AlgorithmCapability.CanSign">
            <summary>The algorithm can be used for signature and verification.</summary>
        </member>
        <member name="F:Libgpgme.AlgorithmCapability.Unknown">
            <summary>The algorithm capabilities are unknown.</summary>
        </member>
        <member name="T:Libgpgme.AlgorithmCapabilityAttribute">
            <summary>Used as field attribute that describes the capability of an algorithm.</summary>
            <remarks>You can use this attribute to determine the capabilities of your cryptographic algorithm.</remarks>
        </member>
        <member name="C:Libgpgme.AlgorithmCapabilityAttribute(Libgpgme.AlgorithmCapability)">
            <param name="type">A <see cref="T:Libgpgme.AlgorithmCapability" /> type.</param>
            <summary>Creates a new AlgorithmCapabilityAttribute.</summary>
            <remarks>You can use this attribute to specify the algorithm capabilities.</remarks>
        </member>
        <member name="F:Libgpgme.AlgorithmCapabilityAttribute.type">
            <summary>Specifies algorithm capabilities.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.AlgorithmCapabilityAttribute.Type">
            <summary>Retrieve the algorithm capabilities.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.AlreadySignedException">
            <summary>Exception that will be raised if a data buffer is already signed.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.AlreadySignedException(System.String)">
            <param name="keyid">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.AlreadySignedException.KeyId">
            <summary>The hexdecimal string representation of a key id.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.AmbiguousKeyException">
            <summary>Exception that will be raised if a key name or key id is ambiguous.</summary>
            <remarks>This Exception will be raised when trying to delete or searching for a particular key and the supplied name or id is ambiguous in the KeyStore (See <see cref="M:Libgpgme.KeyStore.GetKey(System.String,System.Boolean)" /> and <see cref="M:Libgpgme.KeyStore.DeleteKey(Libgpgme.Key,System.Boolean)" />).</remarks>
        </member>
        <member name="C:Libgpgme.AmbiguousKeyException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.AmbiguousKeyException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.BadPassphraseException">
            <summary>Exception that will be raised if the user enters a wrong passphrase.</summary>
            <remarks>The passphrase will be checked three times until an exception is thrown.</remarks>
        </member>
        <member name="C:Libgpgme.BadPassphraseException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.BadPassphraseException(Libgpgme.DecryptionResult)">
            <param name="rst">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.BadPassphraseException(Libgpgme.PassphraseInfo)">
            <param name="info">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.BadPassphraseException.DecryptionResult">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.BadPassphraseException.PassphraseInfo">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.CipherAlgorithm">
            <summary>A type that is used to specify a Symmetric-key algorithm.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.CipherAlgorithm.AES">
            <summary>The Advanced Encryption Standard (AES) with 128 bits key size. Originally published as Rijndael.</summary>
        </member>
        <member name="F:Libgpgme.CipherAlgorithm.AES192">
            <summary>The Advanced Encryption Standard (AES) with 192 bits key size. Originally published as Rijndael.</summary>
        </member>
        <member name="F:Libgpgme.CipherAlgorithm.AES256">
            <summary>The Advanced Encryption Standard (AES) with 256 bits key size. Originally published as Rijndael.</summary>
        </member>
        <member name="F:Libgpgme.CipherAlgorithm.BLOWFISH">
            <summary>The Blowfish algorithm with 128 bits key size.</summary>
        </member>
        <member name="F:Libgpgme.CipherAlgorithm.CAMELLIA128">
            <summary>The Camellia algorithm with 128 bits key size.</summary>
        </member>
        <member name="F:Libgpgme.CipherAlgorithm.CAMELLIA256">
            <summary>The Camellia algorithm with 256 bits key size.</summary>
        </member>
        <member name="F:Libgpgme.CipherAlgorithm.CAST5">
            <summary>The CAST5 (CAST-128) algorithm with 128 bits key size.</summary>
        </member>
        <member name="F:Libgpgme.CipherAlgorithm.DUMMY">
            <summary>Invalid value (reserved for later usage).</summary>
        </member>
        <member name="F:Libgpgme.CipherAlgorithm.IDEA">
            <summary>The International Data Encryption Algorithm (IDEA) with 128 bits key size.
<block subset="none" type="note"><para>
DO NOT USE. The cipher is patented in a number of countries and will expire in 2010â€“2011. You need a separate plugin in order to use IDEA together with GnuPG.
  </para></block></summary>
        </member>
        <member name="F:Libgpgme.CipherAlgorithm.None">
            <summary>None.</summary>
        </member>
        <member name="F:Libgpgme.CipherAlgorithm.TRIPLEDES">
            <summary>The Triple Data Encryption Algorithm (3DES or Triple DES) with 168 bits key size.

<block subset="none" type="note"><para>
Due to the meet-in-the-middle attack the effective security it provides is only 112 bits.
  </para></block></summary>
        </member>
        <member name="F:Libgpgme.CipherAlgorithm.TWOFISH">
            <summary>The Twofish algorithm with 256 bits key size.</summary>
        </member>
        <member name="T:Libgpgme.CombinedResult">
            <summary>A class that contains the decryption and verification result of a combined crypto operation.</summary>
            <remarks>Is the returned object of the <see cref="M:Libgpgme.Context.DecryptAndVerify(Libgpgme.GpgmeData,Libgpgme.GpgmeData)" /> operation.</remarks>
        </member>
        <member name="P:Libgpgme.CombinedResult.DecryptionResult">
            <summary>The result of the decryption from the combined crypto operation.</summary>
            <value>A <see cref="C:Libgpgme.DecryptionResult" /> object.</value>
            <remarks>This is an object used to store the result of a decryption operation.
</remarks>
        </member>
        <member name="P:Libgpgme.CombinedResult.VerificationResult">
            <summary>The result of the verification from the combined crypto operation.</summary>
            <value>A <see cref="C:Libgpgme.VerificationResult" /> object.</value>
            <remarks>This is an object used to store the result of a verification operation.</remarks>
        </member>
        <member name="T:Libgpgme.CompressAlgorithm">
            <summary>A type that is used to specify a compression algorithm.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.CompressAlgorithm.BZIP2">
            <summary>BZIP2 compression used.</summary>
        </member>
        <member name="F:Libgpgme.CompressAlgorithm.None">
            <summary>No compression used.</summary>
        </member>
        <member name="F:Libgpgme.CompressAlgorithm.ZIP">
            <summary>ZIP compression used.</summary>
        </member>
        <member name="F:Libgpgme.CompressAlgorithm.ZLIB">
            <summary>ZLIB compression used.</summary>
        </member>
        <member name="T:Libgpgme.Context">
            <summary>GPGME context for cryptographic operations.</summary>
            <remarks>All cryptographic operations in GPGME are performed within a context, which contains the internal state of the operation as well as configuration parameters.  By using several contexts you can run several cryptographic operations in parallel, with different configuration.
</remarks>
        </member>
        <member name="C:Libgpgme.Context">
            <summary>Creates a new GPGME context.</summary>
            <remarks />
        </member>
        <member name="M:Libgpgme.Context.AddKeylistMode(Libgpgme.KeylistMode)">
            <param name="mode">A <see cref="T:Libgpgme.KeylistMode" /> that shall be added.</param>
            <summary>Can be used to add a single <see cref="T:Libgpgme.KeylistMode" /> to the context.</summary>
            <remarks>If you add the SignatureNotations mode, the Signatures mode will be added as well.</remarks>
        </member>
        <member name="P:Libgpgme.Context.Armor">
            <summary>Specifies if the output should be ASCII armored.</summary>
            <value>
                <see langword="true" /> if ASCII armor output is requested. Otherwise <see langword="false" />.</value>
            <remarks>Must be set before any crypto operation. The default value is <see langword="false" />.</remarks>
        </member>
        <member name="F:Libgpgme.Context.CERTIFICATES_ALL">
            <summary>Include all certificates.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.Context.CERTIFICATES_ALL_EXCEPT_ROOT">
            <summary>Include all certificates except the root certificate.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.Context.CERTIFICATES_DEFAULT">
            <summary>Fall back to the default of the crypto backend.  This is the default for GPGME.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.Context.CERTIFICATES_NO">
            <summary>Include no certificates.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.Context.CERTIFICATES_SENDER_ONLY">
            <summary>Include the sender's certificate only.</summary>
            <remarks />
        </member>
        <member name="M:Libgpgme.Context.ClearPassphraseFunction">
            <summary>Resets the passphrase callback delegate in the context.</summary>
            <remarks />
        </member>
        <member name="M:Libgpgme.Context.Decrypt(Libgpgme.GpgmeData,Libgpgme.GpgmeData)">
            <param name="cipher">A source <see cref="C:Libgpgme.GpgmeData" /> buffer with the ciphertext.</param>
            <param name="plain">A destination <see cref="C:Libgpgme.GpgmeData" /> buffer for the plaintext (decrypted text).</param>
            <summary>Decrypts a ciphertext.</summary>
            <returns>A <see cref="C:Libgpgme.DecryptionResult" /> object with decryption result information.</returns>
            <remarks>The function decrypts the ciphertext in the data object <paramref name="cipher" /> and stores it into the data object <paramref name="plain" />. You need to specify a passphrase callback by using the <see cref="M:Libgpgme.Context.SetPassphraseFunction(Libgpgme.PassphraseDelegate)" /> method if the user does not use gpg-agent or any other passphrase or pin-entry software.
</remarks>
        </member>
        <member name="M:Libgpgme.Context.DecryptAndVerify(Libgpgme.GpgmeData,Libgpgme.GpgmeData)">
            <param name="cipher">A source <see cref="C:Libgpgme.GpgmeData" /> buffer with the ciphertext.</param>
            <param name="plain">A destination <see cref="C:Libgpgme.GpgmeData" /> buffer for the plaintext (decrypted text).</param>
            <summary>Decrypts and verifys a ciphertext.</summary>
            <returns>A <see cref="C:Libgpgme.CombinedResult" /> object with decryption and verification information.</returns>
            <remarks>
                <para>
 The function decrypts the ciphertext in the data object <paramref name="cipher" /> and stores it into the data object <paramref name="plain" />. If <paramref name="cipher" /> contains signatures, they will be verified.
</para>
                <para>
 After the operation completed, the <see cref="C:Libgpgme.EncryptionResult" /> and the <see cref="C:Libgpgme.VerificationResult" /> property inside the <see cref="C:Libgpgme.CombinedResult" /> object can be used to retrieve more information about the signatures.
</para>
                <para>
If the <see cref="P:Libgpgme.CombinedResult.DecryptionResult" /> property is <see langword="null" />, <paramref name="cipher" /> did not contain any data to decrypt. However, it might still be signed. The information about detected signatures is available through the <see cref="P:Libgpgme.CombinedResult.VerificationResult" /> property.
</para>
            </remarks>
        </member>
        <member name="M:Libgpgme.Context.Dispose">
            <summary>Disposes a GPGME context.</summary>
            <remarks> The function destroys the context with its handle and releases all associated resources.
</remarks>
        </member>
        <member name="M:Libgpgme.Context.Encrypt(Libgpgme.Key[],Libgpgme.EncryptFlags,Libgpgme.GpgmeData,Libgpgme.GpgmeData)">
            <param name="recipients">An array of <see cref="T:Libgpgme.Key" /> objects that includes all recipients that shall be able to decrypt the ciphertext.</param>
            <param name="flags">Flags that have an effect on the encryption process.</param>
            <param name="plain">A source <see cref="C:Libgpgme.GpgmeData" /> buffer with the plaintext.</param>
            <param name="cipher">A destination <see cref="C:Libgpgme.GpgmeData" /> buffer for the ciphertext (encrypted text).</param>
            <summary>Encrypts a plaintext.</summary>
            <returns>An <see cref="T:Libgpgme.EncryptionResult" /> object.</returns>
            <remarks>The function encrypts the plaintext in the data object <paramref name="plain" /> for the recipients <paramref name="recipients" /> and stores the ciphertext in the data object <paramref name="cipher" />. The type of the ciphertext created is determined by the ASCII armor (<see cref="P:Libgpgme.Context.Armor" />) and text mode attributes (<see cref="P:Libgpgme.Context.TextMode" />) set in the currently used context.
<para>
If <paramref name="recipients" /> is <see langword="null" />, symmetric rather than public key encryption is performed.  Symmetrically encrypted cipher text can be deciphered with <see cref="M:Libgpgme.Context.Decrypt(Libgpgme.GpgmeData,Libgpgme.GpgmeData)" />.  Note that in this case the crypto backend needs to retrieve a passphrase from the user.  Symmetric encryption is currently only supported for the OpenPGP crypto backend.
</para></remarks>
        </member>
        <member name="M:Libgpgme.Context.EncryptAndSign(Libgpgme.Key[],Libgpgme.EncryptFlags,Libgpgme.GpgmeData,Libgpgme.GpgmeData)">
            <param name="recipients">An array of <see cref="T:Libgpgme.Key" /> objects that includes all recipients that shall be able to decrypt the ciphertext.</param>
            <param name="flags">Flags that have an effect on the encryption process.</param>
            <param name="plain">A source <see cref="C:Libgpgme.GpgmeData" /> buffer with the plaintext.</param>
            <param name="cipher">A destination <see cref="C:Libgpgme.GpgmeData" /> buffer for the ciphertext (encrypted and signed text).</param>
            <summary>A combined crypto operation that encrypts a plaintext and signs the result.</summary>
            <returns>An <see cref="T:Libgpgme.EncryptionResult" /> object.</returns>
            <remarks> The function does a combined encrypt and sign operation.  It is used like <see cref="M:Libgpgme.Context.Encrypt(Libgpgme.Key[],Libgpgme.EncryptFlags,Libgpgme.GpgmeData,Libgpgme.GpgmeData)" />, but the ciphertext also contains signatures for the signers listed in the current Context. See <see cref="P:Libgpgme.Context.Signers" /> for more information.
<block subset="none" type="note"><para>
The combined encrypt and sign operation is currently only available for the OpenPGP crypto engine.
  </para></block></remarks>
        </member>
        <member name="P:Libgpgme.Context.EngineInfo">
            <summary>Retrieves the engine information from the current context.</summary>
            <value>An <see cref="C:Libgpgme.EngineInfo" /> object.</value>
            <remarks>
                <see cref="T:Libgpgme.EngineInfo" /> objects are linked together through the <see cref="P:Libgpgme.EngineInfo.Next" /> property. You actually receive a linked list, that can be enumerated through the <see cref="M:Libgpgme.EngineInfo.GetEnumerator()" /> method.</remarks>
        </member>
        <member name="M:Libgpgme.Context.Finalize">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Context.HasPassphraseFunction">
            <summary>Can be used to determinate whether the current context has a passphrase callback function set or not.</summary>
            <value>A <see cref="T:System.Boolean" />.
<para><see langword="true" /> if the user already specified a passphrase callback function (delegate) by using the <see cref="M:Libgpgme.Context.SetPassphraseFunction(PassphraseDelegate)" /> or <see cref="M:Libgpgme.Context.SetPassphraseFunction(PassphraseDelegate, IntPtr)" /> method.
</para><para><see langword="false" /> if not passphrase callback function has been set (default).
</para></value>
            <remarks>
                <para>
The user can unset the passphrase callback function by calling <see cref="M:Libgpgme.Context.ClearPassphraseFunction()" />.
</para>
            </remarks>
        </member>
        <member name="P:Libgpgme.Context.IncludedCerts">
            <summary>Specifies how many certificates should be included in an S/MIME signed message.</summary>
            <value>An <see cref="T:System.Integer" />. Allowed values are:
<para><list type="table"><listheader><term>Const</term><description>Description</description></listheader><item><term><see cref="P:Libgpgme.Context.CERTIFICATES_ALL" /></term><description>Include all certificates.</description></item><item><term><see cref="P:Libgpgme.Context.CERTIFICATES_ALL_EXCEPT_ROOT" /></term><description>Include all certificates except the root certificate.</description></item><item><term><see cref="P:Libgpgme.Context.CERTIFICATES_DEFAULT" /></term><description>Fall back to the default of the crypto backend.  This is the default for GPGME.</description></item><item><term><see cref="P:Libgpgme.Context.CERTIFICATES_NO" /></term><description>Include no certificates.</description></item><item><term><see cref="P:Libgpgme.Context.CERTIFICATES_SENDER_ONLY" /></term><description>Include the sender's certificate only.</description></item><item><term><paramref name="n" /></term><description>Include the first <paramref name="n" /> certificates of the certificates path, starting from the sender's certificate.  The number <paramref name="n" /> must be positive.</description></item></list></para></value>
            <remarks>The function specifies how many certificates should be included in an S/MIME signed message.  By default, only the sender's certificate is included.</remarks>
        </member>
        <member name="P:Libgpgme.Context.IsValid">
            <summary>Can be used to determinate whether the current context is still valid.</summary>
            <value>
                <para>
                    <see langword="true" /> if the context is still valid.
</para>
                <para>
                    <see langword="false" /> if the context has been disposed.
</para>
            </value>
            <remarks>The context can be disposed by calling <see cref="M:Libgpgme.Context.Dispose()" />.</remarks>
        </member>
        <member name="P:Libgpgme.Context.KeylistMode">
            <summary>Can be used to change the default behaviour of the key listing methods.</summary>
            <value>
                <paramref name="mode" /> is a bitwise-or combination of one or multiple <see cref="T:Libgpgme.KeylistMode" /> values.</value>
            <remarks>
                <para>
This property can be used to change the default behaviour of the key listing methods. The value in <paramref name="mode" /> is a bitwise-or combination of one or multiple <see cref="T:Libgpgme.KeylistMode" /> values.
</para>
                <block subset="none" type="note">
                    <para>
At least one of <see cref="P:Libgpgme.KeylistMode.Local" /> and <see cref="P:Libgpgme.KeylistMode.Extern" /> must be specified.
  </para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.Context.KeyStore">
            <summary>Can be used to retrieve the engine-specific key store.</summary>
            <value>A <see cref="C:Libgpgme.KeyStore" /> object.</value>
            <remarks>A KeyStore usually implements the <see cref="T:Libgpgme.IKeyStore" /> interface.</remarks>
        </member>
        <member name="F:Libgpgme.Context.LastCallbackException">
            <summary>The last <see cref="T:System.Exception" /> that has been thrown during a crypto operation.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.Context.Protocol">
            <summary>The protocol used within the context.</summary>
            <value>A <see cref="T:Libgpgme.Protocol" /> value.</value>
            <remarks>This property sets the protocol used within the context to <paramref name="proto" />. All crypto operations will be performed by the crypto engine configured for that protocol. 
<block subset="none" type="note"><para>
Setting the protocol does not check if the crypto engine for that protocol is available and installed correctly. Use <see cref="M:Libgpgme.Gpgme.EngineCheckVersion(Libgpgme.Protocol)" /> or <see cref="M:Libgpgme.Gpgme.GetEngineInfo()" /> to check availability.
  </para></block></remarks>
        </member>
        <member name="M:Libgpgme.Context.RemoveKeylistMode(Libgpgme.KeylistMode)">
            <param name="mode">A <see cref="T:Libgpgme.KeylistMode" /> that shall be removed.</param>
            <summary>Can be used to remove a single <see cref="T:Libgpgme.KeylistMode" /> from the context.</summary>
            <remarks>If you remove the Signatures mode, the SignatureNotations mode will be removed as well.</remarks>
        </member>
        <member name="M:Libgpgme.Context.SetDllDirectory(System.String)">
            <param name="path">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.Context.SetEngineInfo(Libgpgme.Protocol,System.String,System.String)">
            <param name="proto">Specifies the <see cref="T:Libgpgme.Protocol" /> for which the changes shall take effect.</param>
            <param name="filename">A <see langword="string" /> containing the file name of the executable program implementing protocol <paramref name="proto" /> (the implementing crypto engine).</param>
            <param name="homedir">A <see langword="string" /> containing the directory name of the configuration directory for this crypto engine.</param>
            <summary>Changes the configuration of the crypto engine for the context.

</summary>
            <remarks>The function changes the configuration of the crypto engine implementing the protocol <paramref name="proto" /> for the context.
<para><paramref name="filename" /> is the file name of the executable program implementing this protocol, and <paramref name="homedir" /> is the directory name of the configuration directory for this crypto engine.  If <paramref name="homedir" /> is <see langword="null" />, the engine's default will be used.
</para><block subset="none" type="note"><para>
     Currently this function must be used before starting the first
     crypto operation.  It is unspecified if and when the changes will
     take effect if the function is called after starting the first
     operation on the context.
  </para></block></remarks>
        </member>
        <member name="M:Libgpgme.Context.SetPassphraseFunction(Libgpgme.PassphraseDelegate)">
            <param name="func">A <see cref="T:Libgpgme.PassphraseDelegate" /> (callback function) that will be called if a crypto operation needs a passphrase from the user.</param>
            <summary>Sets a <see cref="T:Libgpgme.PassphraseDelegate" /> (callback function) that will be called if a crypto operation needs a passphrase from the user.</summary>
            <remarks>
                <para>
The function sets the function <paramref name="func" /> that is used when a passphrase needs to be provided by the user.  The function <paramref name="func" /> needs to implemented by the user.  By default, no passphrase callback function is set.
</para>
                <para>
Not all crypto engines require this callback to retrieve the passphrase.  It is better if the engine retrieves the passphrase from a trusted agent (a daemon process), rather than having each user to implement their own passphrase query.  Some engines do not even support an external passphrase callback at all, in this case a <see cref="T:System.NotSupportedException" /> is thrown.
</para>
                <para>
The user can disable the use of a passphrase callback function by calling <see cref="M:Libgpgme.Context.ClearPassphraseFunction()" /> method.
</para>
            </remarks>
        </member>
        <member name="M:Libgpgme.Context.SetPassphraseFunction(Libgpgme.PassphraseDelegate,System.IntPtr)">
            <param name="func">A <see cref="T:Libgpgme.PassphraseDelegate" /> (callback function) that will be called if a crypto operation needs a passphrase from the user.</param>
            <param name="Hook">Whenever <paramref name="func" /> is called, the supplied <see cref="C:Libgpgme.PassphraseInfo" /> object has its property <see cref="P:Libgpgme.PassphraseInfo.Hook" /> set with the value of <paramref name="Hook" />. </param>
            <summary>Sets a <see cref="T:Libgpgme.PassphraseDelegate" /> (callback function) that will be called if a crypto operation needs a passphrase from the user.</summary>
            <remarks>
                <para>
The function sets the function <paramref name="func" /> that is used when a passphrase needs to be provided by the user.  The function <paramref name="func" /> needs to implemented by the user. By default, no passphrase callback function is set.
</para>
                <para>
Not all crypto engines require this callback to retrieve the passphrase.  It is better if the engine retrieves the passphrase from a trusted agent (a daemon process), rather than having each user to implement their own passphrase query.  Some engines do not even support an external passphrase callback at all, in this case a <see cref="T:System.NotSupportedException" /> is thrown.
</para>
                <para>
The user can disable the use of a passphrase callback function by calling <see cref="M:Libgpgme.Context.ClearPassphraseFunction()" /> method.
</para>
            </remarks>
        </member>
        <member name="M:Libgpgme.Context.Sign(Libgpgme.GpgmeData,Libgpgme.GpgmeData,Libgpgme.SignatureMode)">
            <param name="plain">A source <see cref="C:Libgpgme.GpgmeData" /> buffer with the plaintext.</param>
            <param name="sig">A destination <see cref="C:Libgpgme.GpgmeData" /> buffer for the signature.</param>
            <param name="mode">A <see cref="T:Libgpgme.SignatureMode" /> that specifies the desired signature mode.</param>
            <summary>Signs a plaintext.</summary>
            <returns>A <see cref="C:Libgpgme.SignatureResult" /> object.</returns>
            <remarks>
                <para>
 The function creates a signature for the text in the data object <paramref name="plain" /> and returns it in the data object <paramref name="sig" />.  The type of the signature created is determined by the ASCII armor (<see cref="P:Libgpgme.Context.Armor" />) and text mode (<see cref="P:Libgpgme.Context.TextMode" />) attributes set for the context and the requested signature mode <paramref name="mode" />.
</para>
                <para>
The resulting signature in the data buffer <paramref name="sig" /> contains signatures for the signers listed in the current context. See <see cref="P:Libgpgme.Context.Signers" /> for more information.
</para>
                <para>
After the operation completed successfully, the result can be checked through the returned <see cref="C:Libgpgme.SignatureResult" /> object.
</para>
            </remarks>
        </member>
        <member name="P:Libgpgme.Context.SignatureNotations">
            <summary>To specify arbitrary signature notation data.</summary>
            <value>A <see cref="T:Libgpgme.Context+ContextSignatureNotations" /> object.</value>
            <remarks>By using the returned <see cref="T:Libgpgme.Context+ContextSignatureNotations" /> object, you can attach arbitrary notation data
to a signature. This information is then available to the user when the signature is verified.
</remarks>
        </member>
        <member name="P:Libgpgme.Context.Signers">
            <summary>Can be used to modify the list of signers for this context.</summary>
            <value>A <see cref="T:Libgpgme.Context+ContextSigners" /> object.</value>
            <remarks>
                <para>
A signature can contain signatures by one or more signer keys.  The set of keys used to create a signatures is contained in a context, and is applied to all signing operations in this context (until the set is changed).
</para>
                <para>
With the <see cref="P:Libgpgme.Context.Signers" /> property you can list (enumerate), add and remove (clear) all signers from the current context.
</para>
            </remarks>
        </member>
        <member name="P:Libgpgme.Context.TextMode">
            <summary>Specifies if canonical text mode should be used.</summary>
            <value>If <see langword="true" /> Canonical text mode enabled, otherwise it is disabled.</value>
            <remarks>
                <para>
The value of this property specifies if canonical text mode should be used.  By default, text mode is not used.
</para>
                <para>
Text mode is for example used for the RFC2015 signatures; note that the updated RFC 3156 mandates that the mail user agent does some preparations so that text mode is not needed anymore.
</para>
                <block subset="none" type="note">
                    <para>
This option is only relevant to the OpenPGP crypto engine, and ignored by all other engines.
  </para>
                </block>
            </remarks>
        </member>
        <member name="M:Libgpgme.Context.Verify(Libgpgme.GpgmeData,Libgpgme.GpgmeData,Libgpgme.GpgmeData)">
            <param name="signature">A source <see cref="C:Libgpgme.GpgmeData" /> buffer with a detached or normal signature.</param>
            <param name="signedtext">A source <see cref="C:Libgpgme.GpgmeData" /> buffer with the plaintext.</param>
            <param name="plain">A destination <see cref="C:Libgpgme.GpgmeData" /> buffer that contains the plaintext if <paramref name="signature" /> was a normal signature.</param>
            <summary>Verifies a signature.</summary>
            <returns>A <see cref="T:Libgpgme.VerificationResult" /> object.</returns>
            <remarks>
                <para>
The function verifies that the signature in the data object <paramref name="signature" /> is a valid signature. If <paramref name="signature" /> is a detached signature, then the signed text should be provided in <paramref name="signedtext" /> and <paramref name="plain" /> should be <see langword="null" />. Otherwise, if <paramref name="signature" /> is a normal (or cleartext) signature, <paramref name="signedtext" /> should be <see langword="null" /> and <paramref name="plain" /> should be a writable data object that will contain the plaintext after successful verification.
</para>
                <para>
The results of the individual signature verifications can be checked with the returned <see cref="T:Libgpgme.VerificationResult" /> object.
</para>
            </remarks>
        </member>
        <member name="T:Libgpgme.Context+ContextSignatureNotations">
            <summary>A class used to list and modify signature notations data of a context.</summary>
            <remarks>By using the member method <see cref="M:Libgpgme.Context+ContextSignatureNotations.Add(System.String,System.String,Libgpgme.SignatureNotationFlags)" />, you can attach arbitrary notation data to a signature. This information is then available to the user when the signature is verified.
</remarks>
        </member>
        <member name="M:Libgpgme.Context+ContextSignatureNotations.Add(System.String,System.String,Libgpgme.SignatureNotationFlags)">
            <param name="name">A <see cref="T:System.String" /> that contains the Notation name.</param>
            <param name="value">A <see cref="T:System.String" /> that contains the Notation value.</param>
            <param name="flags">To be added.</param>
            <summary>Adds notation data to the context.</summary>
            <remarks>
                <para>
The function adds the notation data with the name <paramref name="name" /> and the value <paramref name="value" /> to the context
</para>
                <para>
Subsequent signing operations will include this notation data, as well as any other notation data that was added since the creation of the context or the last <see cref="M:Libgpgme.Context+ContextSignatureNotations.Clear()" /> operation.
</para>
The arguments <paramref name="name" /> and <paramref name="value" /> must be strings in human-readable form.  The flag <see cref="P:Libgpgme.SignatureNotationFlags.HumanReadable" /> is implied (non-human-readable notation data is currently not supported). The strings must be in UTF-8 encoding (will be automatically transformed when using <see cref="T:System.String" />).
<para>
     If <paramref name="name" /> is <see langword="null" />, then <paramref name="value" /> should be a policy URL.
</para></remarks>
        </member>
        <member name="M:Libgpgme.Context+ContextSignatureNotations.Clear">
            <summary>Removes the notation data from the context.</summary>
            <remarks>The function removes the notation data from the context. Subsequent signing operations from this context will not include any notation data.
<block subset="none" type="note"><para>
Every context starts with an empty notation data list.
  </para></block></remarks>
        </member>
        <member name="M:Libgpgme.Context+ContextSignatureNotations.Get">
            <summary>Receives the notation data from the context.</summary>
            <returns>If notation data is available, a <see cref="C:Libgpgme.SignatureNotation" /> object is returned. If there is currently no notation data added for this context, <see langword="null" /> is returned.</returns>
            <remarks>The function returns a linked list of notation data objects that are contained in the context. You can get the next <see cref="C:Libgpgme.SignatureNotation" /> through the <see cref="P:Libgpgme.SignatureNotation.Next" /> property or enumerate all entries through the <see cref="M:Libgpgme.SignatureNotation.GetEnumerator()" /> method.
</remarks>
        </member>
        <member name="M:Libgpgme.Context+ContextSignatureNotations.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.Context+ContextSignatureNotations.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.Context+ContextSigners">
            <summary>A class used to list and modify the signers of a context.</summary>
            <remarks>
                <para>
The <see cref="C:Libgpgme.Context+ContextSigners" /> class allows you to list (enumerate), add and remove (clear) all signers.
</para>
            </remarks>
        </member>
        <member name="M:Libgpgme.Context+ContextSigners.Add(Libgpgme.Key)">
            <param name="signer">The key that shall be used for cryptographic signing operations.</param>
            <summary>Add a key to the list of signers.</summary>
            <remarks>After adding the key <paramref name="signer" /> to the list of signers it will be used within the <see cref="M:Libgpgme.Context.Sign(Libgpgme.GpgmeData,Libgpgme.GpgmeData,Libgpgme.SignatureMode)" /> and the <see cref="M:Libgpgme.Context.EncryptAndSign(Libgpgme.Key[],Libgpgme.EncryptFlags,Libgpgme.GpgmeData,Libgpgme.GpgmeData)" /> method.</remarks>
        </member>
        <member name="M:Libgpgme.Context+ContextSigners.Clear">
            <summary>Remove all keys from the list of signers.</summary>
            <remarks />
        </member>
        <member name="M:Libgpgme.Context+ContextSigners.Enum(System.Int32)">
            <param name="seq">The number of the key that shall be retrieved.</param>
            <summary>Retrieve a reference to specified signer key.</summary>
            <returns>The <paramref name="seq" /><see cref="C:Libgpgme.Key" /> in the list of signers. <see langword="null" />, if <paramref name="seq" /> is out of range.</returns>
            <remarks />
        </member>
        <member name="M:Libgpgme.Context+ContextSigners.Get">
            <summary>Retrieve an array of all signer keys.</summary>
            <returns>An array of all signer <see cref="C:Libgpgme.Key" />s.</returns>
            <remarks />
        </member>
        <member name="M:Libgpgme.Context+ContextSigners.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.Context+ContextSigners.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.DataEncoding">
            <summary>Specifies the encoding of a <see cref="C:Libgpgme.GpgmeData" /> object.</summary>
            <remarks>This type specifies the encoding of a <see cref="T:Libgpgme.GpgmeData" /> object.  This encoding is useful to give the backend a hint on the type of data.
</remarks>
        </member>
        <member name="F:Libgpgme.DataEncoding.Armor">
            <summary>This specifies that the data is encoded in an armored form as used by OpenPGP and PEM.
</summary>
        </member>
        <member name="F:Libgpgme.DataEncoding.Base64">
            <summary>This specifies that the data is encoded using the Base-64 encoding scheme as used by MIME and other protocols.
</summary>
        </member>
        <member name="F:Libgpgme.DataEncoding.Binary">
            <summary>This specifies that the data is encoding in binary form; i.e. there is no special encoding.
</summary>
        </member>
        <member name="F:Libgpgme.DataEncoding.None">
            <summary>This specifies that the encoding is not known. This is the default for a new data object. The backend will try its best to detect the encoding automatically.
</summary>
        </member>
        <member name="T:Libgpgme.DecryptionFailedException">
            <summary>Exception that will be raised if a decryption failed.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.DecryptionFailedException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.DecryptionFailedException(Libgpgme.DecryptionResult)">
            <param name="rst">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.DecryptionFailedException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.DecryptionFailedException.DecryptionResult">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.DecryptionResult">
            <summary>A class that contains information about a decryption result. </summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.DecryptionResult.FileName">
            <summary>The filename of the original plaintext message file.
</summary>
            <value>A <see cref="T:System.String" /> containing the filename of the original plaintext message file if it is known, otherwise it is <see langword="null" />.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.DecryptionResult.Recipients">
            <summary>Recipients to which a message was encrypted.</summary>
            <value>A <see cref="C:Libgpgme.Recipient" /> object. <see langword="null" /> if the message was not encrypted.</value>
            <remarks>This is a linked list of recipients to which a message was encrypted. You can enumerate the particular recipients through the <see cref="P:Libgpgme.Recipient.Next" /> property or by using the <see cref="M:Libgpgme.Recipient.GetEnumerator()" /> method.</remarks>
        </member>
        <member name="P:Libgpgme.DecryptionResult.UnsupportedAlgorithm">
            <summary>Unsupported algorithm name.</summary>
            <value>A <see cref="T:System.String" /> that describes the algorithm that was not supported.
</value>
            <remarks>If an unsupported algorithm was encountered, this string describes the algorithm that is not supported.
</remarks>
        </member>
        <member name="P:Libgpgme.DecryptionResult.WrongKeyUsage">
            <summary>Signalises the wrong usage of a key.</summary>
            <value>
                <see langword="true" /> if the key was not used according to its policy.</value>
            <remarks />
        </member>
        <member name="T:Libgpgme.EmptyPassphraseException">
            <summary>Exception that will be raised if the user enters an empty passphrase.</summary>
            <remarks>When changing the passphrase of a PGP key you can specify, if empty passwords should be allowed by using the <see cref="P:Libgpgme.PgpPassphraseOptions.EmptyOkay" /> field.</remarks>
        </member>
        <member name="C:Libgpgme.EmptyPassphraseException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.EmptyPassphraseException(Libgpgme.PassphraseInfo)">
            <param name="info">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.EncryptFlags">
            <summary>Flags that affect the encryption process.</summary>
            <remarks>The <see cref="T:Libgpgme.EncryptionResult" /> object contains information if some recipients were invalid. In this case the plaintext might be encrypted for all valid recipients and returned (if this happens depends on the crypto engine).
</remarks>
        </member>
        <member name="F:Libgpgme.EncryptFlags.AlwaysTrust">
            <summary>Specifies that all the recipients should be trusted, even if the keys do not have a high enough validity in the keyring.  This flag should be used with care; in general it is not a good idea to use any untrusted keys.
</summary>
        </member>
        <member name="F:Libgpgme.EncryptFlags.None">
            <summary>Nothing</summary>
        </member>
        <member name="T:Libgpgme.EncryptionResult">
            <summary>A class that contains the status result of an encryption operation.</summary>
            <remarks>
                <para>
During an encryption operation the <see cref="F:Libgpgme.EncryptFlags" /> specify whether trusted keys are required. Invalid recipients are keys that do not have a high enough validity in the keyring.
</para>

The <see cref="T:Libgpgme.EncryptionResult" /> object contains information about invalid recipients. In case of one ore more invalid recipients the plaintext might be encrypted for all valid recipients and returned (if this happens depends on the crypto engine).</remarks>
        </member>
        <member name="P:Libgpgme.EncryptionResult.InvalidRecipients">
            <summary>Recipient keys that do not have a high enough validity in the keyring or require unsupported algorithms.</summary>
            <value>Invalid recipient keys. Is <see langword="null" /> if there were no invalid recipients.</value>
            <remarks>Contains a linked list with information about all invalid keys for which the data could not be encrypted.
</remarks>
        </member>
        <member name="T:Libgpgme.EngineInfo">
            <summary>A class that describes a crypto engine.</summary>
            <remarks>
                <para>
GPGME supports several cryptographic protocols, however, it does not implement them. Rather it uses backends (also called engines) which implement the protocol.  GPGME uses inter-process communication to pass data back and forth between the application and the backend, but the details of the communication protocol and invocation of the backend is completely hidden by the interface.  All complexity is handled by GPGME.  Where an exchange of information between the application and
the backend is necessary, GPGME provides the necessary callback function hooks and further interfaces.
</para>
                <para>
This class is implemented as linked list. You can enumerate all <see cref="C:Libgpgme.EngineInfo" /> objects by using the <see cref="P:Libgpgme.EngineInfo.Next" /> property or the <see cref="M:Libgpgme.EngineInfo.GetEnumerator()" /> method.
</para>
            </remarks>
        </member>
        <member name="P:Libgpgme.EngineInfo.CtxValid">
            <summary>Shows the status of the context the engine is attached to.</summary>
            <value>
                <see langword="true" /> if the attached <see cref="C:Libgpgme.Context" /> object is valid. <see langword="false" /> otherwise.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.EngineInfo.FileName">
            <summary>The file name of the executable of the crypto engine. </summary>
            <value>A <see cref="T:System.String" /> holding the file name of the executable of the crypto engine. 
</value>
            <remarks>Currently, <paramref name="filename" /> is never <see langword="null" />, but using <see langword="null" /> is reserved for future use, so always check before you use it.</remarks>
        </member>
        <member name="M:Libgpgme.EngineInfo.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.EngineInfo.HasCtx">
            <summary>Shows if the engine info has been queried from a <see cref="C:Libgpgme.Context" /> object.</summary>
            <value>A <see cref="T:System.Boolean" />.</value>
            <remarks>It is possible to query engine information without a context by using the static <see cref="M:Libgpgme.Gpgme.GetEngineInfo()" /> method. In this case <see cref="P:Libgpgme.EngineInfo.HasCtx" /> is <see langword="false" />.</remarks>
        </member>
        <member name="P:Libgpgme.EngineInfo.HomeDir">
            <summary>The directory name of the crypto engine's configuration directory.</summary>
            <value>A <see cref="T:System.String" /> holding the directory name of the crypto engine's configuration directory. <see langword="null" /> if the default directory is used.
</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.EngineInfo.Next">
            <summary>A reference to the next EngineInfo object.</summary>
            <value>A reference to the next <see cref="C:Libgpgme.EngineInfo" /> object in the linked list, or <see langword="null" /> if this is the last element.</value>
            <remarks>You can enumerate all <see cref="C:Libgpgme.EngineInfo" /> objects by using the <see cref="M:Libgpgme.EngineInfo.GetEnumerator()" /> method.</remarks>
        </member>
        <member name="P:Libgpgme.EngineInfo.Protocol">
            <summary>The protocol for which the crypto engine is used.</summary>
            <value>A <see cref="T:Libgpgme.Protocol" />.</value>
            <remarks>This is the protocol for which the crypto engine is used. You can convert this to a string with <see cref="M:Libgpgme.Gpgme.GetProtocolName(Libgpgme.Protocol)" /> for printing.
</remarks>
        </member>
        <member name="P:Libgpgme.EngineInfo.ReqVersion">
            <summary>The minimum required version number of the crypto engine for GPGME to work correctly.</summary>
            <value>A <see cref="T:System.String" /> containing a version number.</value>
            <remarks>This is a string containing the minimum required version number of the crypto engine for GPGME to work correctly. This is the version number that <see cref="M:Libgpgme.Gpgme.EngineCheckVersion(Libgpgme.Protocol)" /> verifies against.  Currently, it is never <see langword="null" />, but using <see langword="null" /> is reserved for future use, so always check before you use it.
</remarks>
        </member>
        <member name="M:Libgpgme.EngineInfo.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.EngineInfo.Version">
            <summary>The version number of the crypto engine.</summary>
            <value>A <see cref="T:System.String" /> containing the version number of the crypto engine.</value>
            <remarks>This is a string containing the version number of the crypto engine. It might be <see langword="null" /> if the version number can not be determined, for example because the executable doesn't exist or is invalid.
</remarks>
        </member>
        <member name="T:Libgpgme.GeneralErrorException">
            <summary>Exception that will be raised if an unknown error occurs.</summary>
            <remarks>Errors that are raised by the underlying GPGME backend but cannot be handled by the .NET binding library.</remarks>
        </member>
        <member name="C:Libgpgme.GeneralErrorException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.GenkeyResult">
            <summary>A class that contains information about a new generated key pairs.</summary>
            <remarks>This is a class used to store the result of a <see cref="M:Libgpgme.KeyStore.GenerateKey(Libgpgme.Protocol,Libgpgme.KeyParameters)" /> operation.</remarks>
        </member>
        <member name="P:Libgpgme.GenkeyResult.Fingerprint">
            <summary>A fingerprint of the key that was created.</summary>
            <value>A <see cref="T:System.String" /> that contains the (hexdecimal) fingerprint of the key that was created.</value>
            <remarks>If both a primary and a sub key were generated, the fingerprint of the primary key will be returned. If the crypto engine does
          not provide the fingerprint, <see cref="P:Libgpgme.GenkeyResult.Fingerprint" /> will be <see langword="null" />.

</remarks>
        </member>
        <member name="P:Libgpgme.GenkeyResult.HasPrimary">
            <summary>Indicates if a primary key was created.</summary>
            <value>A <see cref="T:System.Boolean" />.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.GenkeyResult.HasSub">
            <summary>Indicates if a subkey was created.</summary>
            <value>A <see cref="T:System.Boolean" />.</value>
            <remarks />
        </member>
        <member name="T:Libgpgme.Gpgme">
            <summary>Utility class with static methods.</summary>
            <remarks />
        </member>
        <member name="C:Libgpgme.Gpgme">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.Gpgme.CheckVersion">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.Gpgme.CreateContext">
            <summary>Creates a new GPGME context.</summary>
            <returns>The function creates a new <see cref="C:Libgpgme.Context" /> object and returns a handle for it.
</returns>
            <remarks />
        </member>
        <member name="M:Libgpgme.Gpgme.EngineCheckVersion(Libgpgme.Protocol)">
            <param name="proto">A <see cref="T:Libgpgme.Protocol" /> that shall be verified.</param>
            <summary>The function verifys that the engine implementing the protocol <paramref name="proto" /> is installed in the expected path and meets the version requirement of GPGME.
</summary>
            <returns>
                <list type="table">
                    <listheader>
                        <term>Value</term>
                        <description>Description</description>
                    </listheader>
                    <item>
                        <term>
                            <see langword="true" />
                        </term>
                        <description>The engine is available.</description>
                    </item>
                    <item>
                        <term>
                            <see langword="false" />
                        </term>
                        <description>The engine is not available.</description>
                    </item>
                </list>
            </returns>
            <remarks>GPGME supports several cryptographic protocols, however, it does not implement them.  Rather it uses backends (also called engines) which implement the protocol.  GPGME uses inter-process communication to pass data back and forth between the application and the backend, but the details of the communication protocol and invocation of the backend is completely hidden by the interface.  All complexity is handled by
GPGME.  Where an exchange of information between the application and the backend is necessary, GPGME provides the necessary callback function hooks and further interfaces.
</remarks>
        </member>
        <member name="M:Libgpgme.Gpgme.GetAlgorithmCapability``1(``0)">
            <typeparam name="T">To be added.</typeparam>
            <param name="attr">To be added.</param>
            <summary>Returns the algorithm capabilities.</summary>
            <returns>Returns a <see cref="T:Libgpgme.AlgorithmCapability" />.</returns>
            <remarks />
        </member>
        <member name="M:Libgpgme.Gpgme.GetAttrDesc``1(``0)">
            <typeparam name="T">To be added.</typeparam>
            <param name="attr">To be added.</param>
            <summary>Returns the description of an element.</summary>
            <returns>Returns the description <see cref="C:System.String" /> from the <see cref="C:System.ComponentModel.DescriptionAttribute" /> of a field typeof(T).</returns>
            <remarks />
        </member>
        <member name="M:Libgpgme.Gpgme.GetEngineInfo">
            <summary>The function returns engine info objects.
</summary>
            <returns>An <see cref="C:Libgpgme.EngineInfo" /> object.</returns>
            <remarks>Each info object describes the defaults of one configured backend.
<para><see cref="T:Libgpgme.EngineInfo" /> objects are linked together through the <see cref="P:Libgpgme.EngineInfo.Next" /> property. You actually receive a linked list that can be enumerated through the <see cref="M:Libgpgme.EngineInfo.GetEnumerator()" /> method.
</para></remarks>
        </member>
        <member name="M:Libgpgme.Gpgme.GetHashAlgoName(Libgpgme.HashAlgorithm)">
            <param name="algo">A <see cref="T:Libgpgme.HashAlgorithm" /> you want the pretty name from.</param>
            <summary>The function returns a string containing a description a hash algorithm.
</summary>
            <returns>The function returns a string containing a description of the hash algorithm <paramref name="algo" />. If <paramref name="algo" /> is not a valid hash algorithm, <see langword="null" /> is returned.</returns>
            <remarks>This string can be used to output the name of the hash algorithm to the user. Hash (message digest) algorithms are used to compress a long message to make it suitable for public key cryptography.
</remarks>
        </member>
        <member name="M:Libgpgme.Gpgme.GetProtocolName(Libgpgme.Protocol)">
            <param name="proto" />
            <summary>Returns a string with a printable name of the protocol used by a crypto engine.
</summary>
            <returns>Returns a string with a printable name of the protocol used by a crypto engine.</returns>
            <remarks />
        </member>
        <member name="M:Libgpgme.Gpgme.GetPubkeyAlgoName(Libgpgme.KeyAlgorithm)">
            <param name="algo">A <see cref="T:Libgpgme.KeyAlgorithm" /> you want a printable name from.</param>
            <summary>The function returns a string containing a description a public key algorithm.
</summary>
            <returns>Returns a string containing a description of the public key algorithm <paramref name="algo" />.
If <paramref name="algo" /> is not a valid public key algorithm, <see langword="null" /> is returned.</returns>
            <remarks>This string can be used to output the name of the public key algorithm to the user. Public key algorithms are used for encryption, decryption, signing and verification of signatures.
</remarks>
        </member>
        <member name="M:Libgpgme.Gpgme.GetStrError(System.Int32)">
            <param name="err">An <see langword="int" /> that contains the number you want the error message from.</param>
            <summary>The function returns a string containing a description of an error code.</summary>
            <returns>A <see langword="string" /> containing a description of the error code contained in the error value <paramref name="err" />.</returns>
            <remarks>This string can be used to output a diagnostic message to the user.
<block subset="none" type="note"><para>
This function is not thread safe.  Use <see cref="M:Libgpgme.Gpgme.GetStrError(System.Int32,System.String&amp;)" /> in multi-threaded programs.
  </para></block></remarks>
        </member>
        <member name="M:Libgpgme.Gpgme.GetStrError(System.Int32,System.String@)">
            <param name="err">An <see langword="int" /> containing the error code.</param>
            <param name="message">A <see langword="string" /> that recieves the error message.</param>
            <summary>The function returns an error description into a user supplied <see langword="string" />.</summary>
            <remarks>
                <block subset="none" type="note">
                    <para>
 This function is, in contrast to <see cref="M:Libgpgme.Gpgme.GetStrError(System.Int32)" />, thread-safe if a thread-safe strerror_r() function is provided by the system.
  </para>
                </block>
            </remarks>
        </member>
        <member name="M:Libgpgme.Gpgme.GetStrSource(System.Int32)">
            <param name="err">An <see langword="int" /> that contains the number you want the error source from.</param>
            <summary>The function returns a string containing a description of an error source. </summary>
            <returns>A string containing a description of the error source contained in the error value <paramref name="err" />. </returns>
            <remarks>This string can be used to output a diagnostic message to the user.</remarks>
        </member>
        <member name="P:Libgpgme.Gpgme.Version">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.GpgmeCbsData">
            <summary>An abstract class for callback based data buffers.</summary>
            <remarks>If neither memory nor file based data objects are a good fit for your application, you can inherit from this class and implement the required callback functions by yourself.
</remarks>
        </member>
        <member name="C:Libgpgme.GpgmeCbsData">
            <summary>Creates a new callback based data buffer.</summary>
            <remarks>
                <block subset="none" type="note">
                    <para>
Your inherited class must override the following properies:

<list type="table"><listheader><term>Name</term><description>Method</description></listheader><item><term>CanRead</term><description><see cref="P:System.IO.Stream.CanRead" /></description></item><item><term>CanWrite</term><description><see cref="P:System.IO.Stream.CanWrite" /></description></item><item><term>CanSeek</term><description><see cref="P:System.IO.Stream.CanSeek" /></description></item><item><term>CanRelease</term><description><see cref="P:Libgpgme.GpgmeCbsData.CanRelease" /></description></item></list></para>
                    <para>
The GPGME backend will do callbacks only for methods for which their Can* properties returned <see langword="true" /> at initialisation time.
</para>
                </block>
            </remarks>
        </member>
        <member name="C:Libgpgme.GpgmeCbsData(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <param name="canRead">If <see langword="true" />, read() callbacks from the GPGME backend will be enabled.</param>
            <param name="canWrite">If <see langword="true" />, write() callbacks from the GPGME backend will be enabled.</param>
            <param name="canSeek">If <see langword="true" />, seek() callbacks from the GPGME backend will be enabled.</param>
            <param name="canRelease">If <see langword="true" />, release() callbacks from the GPGME backend will be enabled.</param>
            <summary>Creates a new callback based data buffer.</summary>
            <remarks>
                <block subset="none" type="note">
                    <para>
Your inherited class must override the following properies:

<list type="table"><listheader><term>Name</term><description>Method</description></listheader><item><term>CanRead</term><description><see cref="P:System.IO.Stream.CanRead" /></description></item><item><term>CanWrite</term><description><see cref="P:System.IO.Stream.CanWrite" /></description></item><item><term>CanSeek</term><description><see cref="P:System.IO.Stream.CanSeek" /></description></item><item><term>CanRelease</term><description><see cref="P:Libgpgme.GpgmeCbsData.CanRelease" /></description></item></list></para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.GpgmeCbsData.CanRead">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeCbsData.CanRelease">
            <summary>Indicates if GPGME will callback if a user-implemented data object should be destroyed.</summary>
            <value>A <see cref="T:System.Boolean" />. If <see langword="true" />, the inherited class must implement (override) the <see cref="M:Libgpgme.GpgmeCbsData.ReleaseCB()" /> method.</value>
            <remarks>Release functions are called by GPGME if it wants to destroy a user-implemented data object. 

</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeCbsData.CanSeek">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeCbsData.CanWrite">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeCbsData.Dispose(System.Boolean)">
            <param name="disposing">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeCbsData.Finalize">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.GpgmeCbsData.LastCallbackException">
            <summary>The last exception that occurred during a callback from the GPGME backend operation.</summary>
            <remarks>Exception must not be propagated to P/Invoke functions. Therefore any exception that occurs during a callback will be saved into this field.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeCbsData.ReadCB(System.IntPtr,System.Int64)">
            <param name="bufPtr">A pointer to the system memory where the requested number of bytes must be written.</param>
            <param name="size">The requested number of bytes.</param>
            <summary>This is the function which GPGME calls if it wants to read data from a user-implemented data object.</summary>
            <returns>The number of bytes that have been written OR <see cref="P:Libgpgme.GpgmeData.ERROR" /> on any error.</returns>
            <remarks>It is only required for input data objects (i.e. <see cref="P:System.IO.Stream.CanRead" /> is <see langword="true" />).

<block subset="none" type="note"><para>
The <see cref="M:System.Runtime.InteropServices.Marshal.Copy" /> method is recommended to copy data from managed to unmanaged memory.
  </para></block></remarks>
        </member>
        <member name="M:Libgpgme.GpgmeCbsData.ReleaseCB">
            <summary>This is the function which GPGME calls if it wants to destroy a user-implemented data object.</summary>
            <remarks />
        </member>
        <member name="M:Libgpgme.GpgmeCbsData.SeekCB(System.Int64,System.IO.SeekOrigin)">
            <param name="offset">Specifies the byte offset relative to origin.</param>
            <param name="whence">A <see cref="T:System.IO.SeekOrigin" /> value indicating the reference point used to obtain the new position.</param>
            <summary>This is the function which GPGME calls if it wants to change the current read/write position in a user-implemented data object (stream).</summary>
            <returns>
                <para>
Returns the new position within the current stream OR <see cref="P:Libgpgme.GpgmeData.ERROR" /> on any error..</para>
            </returns>
            <remarks>It is only required if <see cref="P:System.IO.Stream.CanSeek" /> is <see langword="true" />.
</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeCbsData.SeekCB(System.IntPtr,System.IO.SeekOrigin)">
            <param name="offset">A <see cref="T:System.IntPtr" /> that specifies the byte offset relative to origin.</param>
            <param name="whence">A <see cref="T:System.IO.SeekOrigin" /> value indicating the reference point used to obtain the new position.</param>
            <summary>This is the function which GPGME calls if it wants to change the current read/write position in a user-implemented data object (stream).</summary>
            <returns>
                <para>A <see cref="T:System.IntPtr" /> that specifies the new position within the current stream OR <see cref="P:Libgpgme.GpgmeData.ERROR" /> on any error..</para>
            </returns>
            <remarks>It is only required if <see cref="P:System.IO.Stream.CanSeek" /> is <see langword="true" />.
</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeCbsData.WriteCB(System.IntPtr,System.Int64)">
            <param name="bufPtr">A pointer to the system memory where the requested number of bytes can be read.</param>
            <param name="size">The requested number of bytes.</param>
            <summary>This is the function which GPGME calls if it wants to write data to a user-implemented data object.</summary>
            <returns>The number of bytes that have been read from the memory and written into the user-implemented stream OR <see cref="P:Libgpgme.GpgmeData.ERROR" /> on any error.</returns>
            <remarks>It is only required for output data objects (i.e. <see cref="P:System.IO.Stream.CanWrite" /> is <see langword="true" />).

<block subset="none" type="note"><para>
The <see cref="M:System.Runtime.InteropServices.Marshal.Copy" /> method is recommended to copy data from managed to unmanaged memory.
  </para></block></remarks>
        </member>
        <member name="T:Libgpgme.GpgmeData">
            <summary>A class which is used by GPGME to exchange data with the user.</summary>
            <remarks>A lot of data has to be exchanged between the user and the crypto engine, like plaintext messages, ciphertext, signatures and information about the keys. The technical details about exchanging the data information are completely abstracted by GPGME.  The user provides and receives the data via <see cref="T:Libgpgme.GpgmeData" /> objects, regardless of the communication protocol between GPGME and the crypto engine in use.
</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeData.Encoding">
            <summary>Specifies the encoding of this object.</summary>
            <value>A <see cref="T:Libgpgme.DataEncoding" />.</value>
            <remarks />
        </member>
        <member name="F:Libgpgme.GpgmeData.EOF">
            <summary>End of file value.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.GpgmeData.ERROR">
            <summary>Error value.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.GpgmeData.FileName">
            <summary>The file name associated with the data object.</summary>
            <value>A <see cref="T:System.String" /> containing the file name associated with the data object. <see langword="null" /> if no file name has been specified.</value>
            <remarks>The file name will be stored in the output when encrypting or signing the data and will be returned to the user when decrypting or verifying the output data.
</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeData.IsValid">
            <summary>Indicates if the data buffer is still valid.</summary>
            <value>A <see cref="T:System.Boolean" />.</value>
            <remarks>A data buffer will become invalid when calling the <see cref="M:Libgpgme.GpgmeData.Close()" /> method.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeData.Position">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeData.Read(System.Byte[])">
            <param name="buffer">A <see cref="T:System.Byte" /> array as destination buffer. </param>
            <summary>Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</summary>
            <returns>
                <para> A <see cref="T:System.Integer" /> that specifies the total number of bytes read into the buffer, or zero if the end of the stream has been reached before any data can be read.</para>
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="note">
Use the <see cref="P:System.IO.Stream.CanRead" /> property to determine whether the current instance supports reading.
</block>
                </para>
            </remarks>
        </member>
        <member name="M:Libgpgme.GpgmeData.Read(System.Byte[],System.Int32)">
            <param name="buffer">A <see cref="T:System.Byte" /> array as destination buffer.  </param>
            <param name="count">The number of bytes to read.</param>
            <summary>Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</summary>
            <returns>
                <para> A <see cref="T:System.Integer" /> that specifies the total number of bytes read into the buffer, or zero if the end of the stream has been reached before any data can be read.</para>
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="note">
Use the <see cref="P:System.IO.Stream.CanRead" /> property to determine whether the current instance supports reading.
</block>
                </para>
            </remarks>
        </member>
        <member name="M:Libgpgme.GpgmeData.Read(System.Byte[],System.Int32,System.Int32)">
            <param name="buffer">To be added.</param>
            <param name="offset">To be added.</param>
            <param name="count">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeData.Rewind">
            <summary>Sets the position in the stream to the beginning.</summary>
            <remarks>
                <para>
                    <block subset="none" type="note">Use the <see cref="P:System.IO.Stream.CanSeek" /> property to determine whether
   the current instance supports seeking.</block>
                </para>
            </remarks>
        </member>
        <member name="M:Libgpgme.GpgmeData.Seek(System.Int64,System.IO.SeekOrigin)">
            <param name="offset">To be added.</param>
            <param name="whence">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.GpgmeData.SEEK_CUR">
            <summary>Indicates that the seek reference point is the current position within a stream.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.GpgmeData.SEEK_END">
            <summary>Indicates that the seek reference point is the first byte beyond the end of a stream. </summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.GpgmeData.SEEK_SET">
            <summary>Indicates that the seek reference point is the beginning of a stream.</summary>
            <remarks />
        </member>
        <member name="M:Libgpgme.GpgmeData.SetLength(System.Int64)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeData.Write(System.Byte[],System.Int32)">
            <param name="buffer">A <see cref="T:System.Byte" /> array containing the data to write.</param>
            <param name="count">A <see cref="T:System.Integer" /> that specifies the number of bytes to be written to the current stream.</param>
            <summary>Writes a sequence of bytes to the current stream and advances the current position within the current stream by the number of bytes written.</summary>
            <returns>A <see cref="T:System.Integer" /> with the number of bytes written.</returns>
            <remarks>
                <para>
                    <block subset="none" type="note">Use the <see cref="P:System.IO.Stream.CanWrite" /> property to determine whether
   the current instance supports writing.</block>
                </para>
                <para>
                    <block subset="none" type="behaviors">If the write operation is
   successful, the position within the stream advances by the number of bytes
   written. If an exception occurs, the position within the stream remains
   unchanged.</block>
                </para>
            </remarks>
        </member>
        <member name="M:Libgpgme.GpgmeData.Write(System.Byte[],System.Int32,System.Int32)">
            <param name="buffer">To be added.</param>
            <param name="offset">To be added.</param>
            <param name="count">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.GpgmeException">
            <summary>Exception that will be raised if an GPGME error occurs.</summary>
            <remarks>All GPGME specific exceptions are inherited from this class.</remarks>
        </member>
        <member name="C:Libgpgme.GpgmeException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.GpgmeException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.GpgmeException(System.String,System.Int32)">
            <param name="message">To be added.</param>
            <param name="GPGMEError">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.GpgmeException.GPGMEError">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.GpgmeFileData">
            <summary>File based data buffer.</summary>
            <remarks>File based data objects operate on streams. Only a small amount of data is stored in core at any time, so the size of the data objects is not limited by GPGME.

<block subset="none" type="note"><para>
The current .NET implementation of the GpgmeFileData class is inherited from the <see cref="C:Libgpgme.GpgmeStreamData" /> class. All data that will be read from - or written to the file stream needs to be passed from managed to unmanaged memory and vice versa. A more efficient implementation that directly passes a C file descriptor or stream to GPGME is planned for future releases.
  </para></block></remarks>
        </member>
        <member name="C:Libgpgme.GpgmeFileData(System.String)">
            <param name="filename">A <see cref="T:System.String" /> containing the requested filename.</param>
            <summary>Creates a new file based data buffer.</summary>
            <remarks>The file will be opened with <see cref="P:System.IO.FileMode.OpenOrCreate" />, <see cref="P:System.IO.FileAccess.ReadWrite" /> and <see cref="P:System.IO.FileShare.None" />.</remarks>
        </member>
        <member name="C:Libgpgme.GpgmeFileData(System.String,System.IO.FileMode)">
            <param name="filename">A <see cref="T:System.String" /> containing the requested filename.</param>
            <param name="mode">The desired <see cref="T:System.IO.FileMode" />.</param>
            <summary>Creates a new file based data buffer.</summary>
            <remarks>The file will be opened with <see cref="P:System.IO.FileAccess.ReadWrite" /> and <see cref="P:System.IO.FileShare.None" />.</remarks>
        </member>
        <member name="C:Libgpgme.GpgmeFileData(System.String,System.IO.FileMode,System.IO.FileAccess)">
            <param name="filename">A <see cref="T:System.String" /> containing the requested filename.</param>
            <param name="mode">The desired <see cref="T:System.IO.FileMode" />.</param>
            <param name="access">The desired <see cref="T:System.IO.FileAccess" />.</param>
            <summary>Creates a new file based data buffer.</summary>
            <remarks>The file will be opened with <see cref="P:System.IO.FileShare.None" />.</remarks>
        </member>
        <member name="C:Libgpgme.GpgmeFileData(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <param name="filename">A <see cref="T:System.String" /> containing the requested filename.</param>
            <param name="mode">The desired <see cref="T:System.IO.FileMode" />.</param>
            <param name="access">The desired <see cref="T:System.IO.FileAccess" />.</param>
            <param name="share">The desired <see cref="T:System.IO.FileShare" />.</param>
            <summary>Creates a new file based data buffer.</summary>
            <remarks />
        </member>
        <member name="M:Libgpgme.GpgmeFileData.Close">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.GpgmeMemoryData">
            <summary>Memory based data buffer.</summary>
            <remarks>Memory based data objects store all data in allocated memory.  This is convenient, but only practical for an amount of data that is a fraction of the available physical memory.  The data has to be copied from its source and to its destination, which can often be avoided by using one of the other data objects.
</remarks>
        </member>
        <member name="C:Libgpgme.GpgmeMemoryData">
            <summary>Creates a new memory based data buffer.</summary>
            <remarks>The new memory buffer is empty. The size will grow automatically.</remarks>
        </member>
        <member name="C:Libgpgme.GpgmeMemoryData(System.Int32)">
            <param name="size">A <see cref="T:System.Integer" /> with the requested data buffer size.</param>
            <summary>Creates a new memory based data buffer with the specified size.</summary>
            <remarks>The memory will be allocated by the .NET runtime environment and a pointer is passed to GPGME.</remarks>
        </member>
        <member name="C:Libgpgme.GpgmeMemoryData(System.String)">
            <param name="filename">A <see cref="T:System.String" /> containing the requested filename.</param>
            <summary>Creates a new memory based data buffer and fills it with the content of a file.</summary>
            <remarks>
                <para>
Creates a new <see cref="C:Libgpgme.GpgmeData" /> object and fills it with the content of the file <paramref name="filename" />.
</para>
                <para>
The whole file is read in at initialization time and the file is not used anymore after that. This is the only mode supported currently.  Later, there might an option causing all reads to be delayed until the data is needed, but this is not yet implemented.
</para>
            </remarks>
        </member>
        <member name="C:Libgpgme.GpgmeMemoryData(System.IntPtr,System.Int32)">
            <param name="memAddr">A <see cref="T:System.IntPtr" /> containing the address of the allocated memory.</param>
            <param name="size">An <see cref="T:System.Integer" /> that specifies the memory size.</param>
            <summary>Creates a new memory based data buffer using the specified address. </summary>
            <remarks>
                <block subset="none" type="note">
                    <para>
The data is taken from the specified buffer as needed, and the user has to ensure that the buffer remains valid for the whole life span of the data object.
  </para>
                </block>
            </remarks>
        </member>
        <member name="C:Libgpgme.GpgmeMemoryData(System.String,System.Int32,System.Int32)">
            <param name="filename">A <see cref="T:System.String" /> containing the requested filename.</param>
            <param name="offset">A <see cref="T:System.Integer" /> with the start offset to read from.</param>
            <param name="length">A <see cref="T:System.Integer" /> with the requested length.</param>
            <summary>Creates a new memory based data buffer and fills it with the content of file parts.</summary>
            <remarks />
        </member>
        <member name="C:Libgpgme.GpgmeMemoryData(System.String,System.Int64,System.Int64)">
            <param name="filename">To be added.</param>
            <param name="offset">To be added.</param>
            <param name="length">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeMemoryData.CanRead">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeMemoryData.CanSeek">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeMemoryData.CanWrite">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeMemoryData.Dispose(System.Boolean)">
            <param name="disposing">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeMemoryData.Finalize">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeMemoryData.Flush">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeMemoryData.IsValid">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeMemoryData.Length">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeMemoryData.MemoryAddress">
            <summary>Address of the allocated memory.</summary>
            <value>A <see cref="T:System.IntPtr" /> containing a memory address.</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
It contains only valid data if either the <see cref="C:Libgpgme.GpgmeMemoryData(System.Int32)" /> or <see cref="C:Libgpgme.GpgmeMemoryData(System.IntPtr,System.Int32)" /> contructor has been used.
  </para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.GpgmeMemoryData.MemorySize">
            <summary>Size of the allocated memory.</summary>
            <value>A <see cref="T:System.Int64" /> with the number of allocated bytes.</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
It contains only valid data if either the <see cref="C:Libgpgme.GpgmeMemoryData(System.Int32)" /> or <see cref="C:Libgpgme.GpgmeMemoryData(System.IntPtr,System.Int32)" /> contructor has been used.
  </para>
                </block>
            </remarks>
        </member>
        <member name="T:Libgpgme.GpgmeStreamData">
            <summary>Stream based data buffer.</summary>
            <remarks>The GpgmeStreamData class is inherited from the <see cref="C:Libgpgme.GpgmeCbsData" /> class.
<block subset="none" type="note"><para>
Make sure that your supplied <see cref="T:System.IO.Stream" /> object has a working implementation of the <see cref="P:System.IO.Stream.Position" /> property, otherwise GPGME's write() callback will not work.
  </para></block></remarks>
        </member>
        <member name="C:Libgpgme.GpgmeStreamData">
            <summary>Creates a new GpgmeStreamData instance.</summary>
            <remarks>
                <block subset="none" type="note">
                    <para>
Make sure that you set a proper <see cref="P:Libgpgme.GpgmeStreamData.iostream" /> property.
Your inherited class must override the following properies:

<list type="table"><listheader><term>Name</term><description>Method</description></listheader><item><term>CanRead</term><description><see cref="P:System.IO.Stream.CanRead" /></description></item><item><term>CanWrite</term><description><see cref="P:System.IO.Stream.CanWrite" /></description></item><item><term>CanSeek</term><description><see cref="P:System.IO.Stream.CanSeek" /></description></item><item><term>CanRelease</term><description><see cref="P:Libgpgme.GpgmeCbsData.CanRelease" /></description></item></list></para>
                    <para>
The GPGME backend will do callbacks only for methods for which their Can* properties returned <see langword="true" /> at initialisation time.
</para>
                </block>
            </remarks>
        </member>
        <member name="C:Libgpgme.GpgmeStreamData(System.IO.Stream)">
            <param name="streamobj">A <see cref="C:System.IO.Stream" /> object.</param>
            <summary>Creates a new GpgmeStreamData instance based on a user-supplied <see cref="C:System.IO.Stream" />.</summary>
            <remarks>
                <block subset="none" type="note">
                    <para>
The stream should support the <see cref="P:System.IO.Stream.Position" /> property, otherwise GPGME cannot write any data to it.
  </para>
                </block>
            </remarks>
        </member>
        <member name="C:Libgpgme.GpgmeStreamData(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <param name="canRead">If <see langword="true" />, read() callbacks from the GPGME backend will be enabled.</param>
            <param name="canWrite">If <see langword="true" />, write() callbacks from the GPGME backend will be enabled.</param>
            <param name="canSeek">If <see langword="true" />, seek() callbacks from the GPGME backend will be enabled.</param>
            <param name="canRelease">If <see langword="true" />, release() callbacks from the GPGME backend will be enabled.</param>
            <summary>Creates a new GpgmeStreamData instance.</summary>
            <remarks>
                <block subset="none" type="note">
                    <para>
Make sure that you set a proper <see cref="P:Libgpgme.GpgmeStreamData.iostream" /> property.
Your inherited class must override the following properies:

<list type="table"><listheader><term>Name</term><description>Method</description></listheader><item><term>CanRead</term><description><see cref="P:System.IO.Stream.CanRead" /></description></item><item><term>CanWrite</term><description><see cref="P:System.IO.Stream.CanWrite" /></description></item><item><term>CanSeek</term><description><see cref="P:System.IO.Stream.CanSeek" /></description></item><item><term>CanRelease</term><description><see cref="P:Libgpgme.GpgmeCbsData.CanRelease" /></description></item></list></para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.GpgmeStreamData.CanRead">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeStreamData.CanRelease">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeStreamData.CanSeek">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeStreamData.CanTimeout">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeStreamData.CanWrite">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeStreamData.Dispose(System.Boolean)">
            <param name="disposing">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeStreamData.Finalize">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeStreamData.Flush">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.GpgmeStreamData.iostream">
            <summary>The origin stream object.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.GpgmeStreamData.IsValid">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeStreamData.Length">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeStreamData.OriginStream">
            <summary>The origin stream object.</summary>
            <value>A <see cref="T:System.IO.Stream" />.</value>
            <remarks />
        </member>
        <member name="M:Libgpgme.GpgmeStreamData.ReadCB(System.IntPtr,System.Int64)">
            <param name="bufPtr">To be added.</param>
            <param name="size">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeStreamData.ReleaseCB">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeStreamData.SeekCB(System.Int64,System.IO.SeekOrigin)">
            <param name="offset">To be added.</param>
            <param name="whence">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeStreamData.SetLength(System.Int64)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.GpgmeStreamData.WriteCB(System.IntPtr,System.Int64)">
            <param name="bufPtr">To be added.</param>
            <param name="size">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.GpgmeVersion">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.GpgmeVersion(System.String)">
            <param name="version">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeVersion.Major">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeVersion.Minor">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeVersion.Update">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.GpgmeVersion.Version">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.HashAlgorithm">
            <summary>Specifies the set of all hash algorithms that are supported by GPGME.</summary>
            <remarks>Hash (message digest) algorithms are used to compress a long message to make it suitable for public key cryptography.</remarks>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.CRC24_RFC2440">
            <summary>CRC24_RFC2440</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.CRC32">
            <summary>CRC32</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.CRC32_RFC1510">
            <summary>CRC32_RFC1510</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.HAVAL">
            <summary>HAVAL</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.MD2">
            <summary>MD2</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.MD4">
            <summary>MD4</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.MD5">
            <summary>MD5</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.None">
            <summary>None</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.RMD160">
            <summary>RMD160</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.SHA1">
            <summary>SHA1</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.SHA224">
            <summary>SHA224</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.SHA256">
            <summary>SHA256</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.SHA384">
            <summary>SHA384</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.SHA512">
            <summary>SHA512</summary>
        </member>
        <member name="F:Libgpgme.HashAlgorithm.TIGER">
            <summary>TIGER</summary>
        </member>
        <member name="T:Libgpgme.IKeyGenerator">
            <summary>An interface that contains the basic methods needed to create new keys.</summary>
            <remarks>A KeyStore that implements <see cref="T:Libgpgme.IKeyGenerator" /> can be used to generate new keys (key pairs). 
<block subset="none" type="note"><para>
For documentation of GPGME's engine specific keystore(s) see <see cref="P:Libgpgme.Context.KeyStore" /> and <see cref="C:Libgpgme.KeyStore" />.
  </para></block></remarks>
        </member>
        <member name="M:Libgpgme.IKeyGenerator.GenerateKey(Libgpgme.Protocol,Libgpgme.KeyParameters)">
            <param name="protocoltype">A <see cref="T:Libgpgme.Protocol" /> the specifies the type of the new key pairs.</param>
            <param name="keyparms">A <see cref="C:Libgpgme.KeyParameters" /> object.</param>
            <summary>Generates a new key.</summary>
            <returns>A <see cref="C:Libgpgme.GenkeyResult" /> object that contains information about a new generated key pairs. </returns>
            <remarks>
                <block subset="none" type="note">
                    <para>
Currently only the OpenPGP protocol is supported.
  </para>
                </block>
            </remarks>
        </member>
        <member name="T:Libgpgme.IKeyStore">
            <summary>An interface that contains the basic methods to retrieve key information.</summary>
            <remarks>A KeyStore that implements <see cref="T:Libgpgme.IKeyStore" /> provides all methods needed to import, export, delete and enumerate keys.

<block subset="none" type="note"><para>
For documentation of GPGME's engine specific keystore(s) see <see cref="P:Libgpgme.Context.KeyStore" /> and <see cref="C:Libgpgme.KeyStore" />.
  </para></block></remarks>
        </member>
        <member name="M:Libgpgme.IKeyStore.DeleteKey(Libgpgme.Key,System.Boolean)">
            <param name="key">The <see cref="C:Libgpgme.Key" /> that shall be deleted from the store.</param>
            <param name="deleteSecret">If <see langword="true" /> the secret key will be deleted as well.</param>
            <summary>Can be used to delete a specific key from the store.</summary>
            <remarks>The function deletes the key <paramref name="key" /> from the keyring.  If <paramref name="deleteSecret" /> is <see langword="false" />, only public keys are deleted, otherwise secret keys are deleted as well, if that is supported.
</remarks>
        </member>
        <member name="M:Libgpgme.IKeyStore.Export(System.String,Libgpgme.GpgmeData)">
            <param name="pattern">A <see cref="T:System.String" /> containing an engine specific expression that is used to limit the list of returned keys.</param>
            <param name="keydata">A destination <see cref="C:Libgpgme.GpgmeData" /> buffer.</param>
            <summary>Extracts public keys and returns them in a user-supplied data buffer.</summary>
            <remarks>
                <para>
The function extracts public keys and returns them in the data buffer <paramref name="keydata" />.
</para>
                <para>
If <paramref name="pattern" /> is <see langword="null" />, all available keys are returned.  Otherwise, <paramref name="pattern" /> contains an engine specific expression that is used to limit the list to all keys matching the pattern.
</para>
            </remarks>
        </member>
        <member name="M:Libgpgme.IKeyStore.Export(System.String[],Libgpgme.GpgmeData)">
            <param name="pattern">An array of <see cref="T:System.String" />s, each containing an engine specific expression that is used to limit the list of returned keys.</param>
            <param name="keydata">A destination <see cref="C:Libgpgme.GpgmeData" /> buffer.</param>
            <summary>Extracts public keys and returns them in a user-supplied data buffer.</summary>
            <remarks>
                <para>
The function extracts public keys and returns them in the data buffer <paramref name="keydata" />.
</para>
                <para>
If <paramref name="pattern" /> is <see langword="null" />, all available keys are returned.  Otherwise, <paramref name="pattern" /> contains an array of engine specific expressions that are used to limit the list to all keys matching the pattern.
</para>
            </remarks>
        </member>
        <member name="M:Libgpgme.IKeyStore.GetKey(System.String,System.Boolean)">
            <param name="fpr">A <see cref="T:System.String" /> containing the fingerprint (or key ID) of the requested key.</param>
            <param name="secretOnly">If <see langword="true" />, get the secret key.</param>
            <summary>Can be used to retrieve a single key.</summary>
            <returns>A <see cref="C:Libgpgme.Key" /> object.</returns>
            <remarks />
        </member>
        <member name="M:Libgpgme.IKeyStore.GetKeyList(System.String,System.Boolean)">
            <param name="pattern">A <see cref="T:System.String" /> containing an engine specific expression that is used to limit the list of returned <see cref="C:Libgpgme.Key" /> objects.</param>
            <param name="secretOnly">If <see langword="true" />, the returning list is restricted to secret keys only.</param>
            <summary>Initiates a key listing operation.</summary>
            <returns>An array of <see cref="C:Libgpgme.Key" /> objects. Depending on the engine <see cref="C:Libgpgme.PgpKey" />s or <see cref="C:Libgpgme.X509Key" />s are returned.</returns>
            <remarks>
                <para>
If <paramref name="pattern" /> is <see langword="null" />, all available keys are returned.  Otherwise, <paramref name="pattern" /> contains an engine specific expression that is used to limit the list to all keys matching the pattern.  
</para>
                <block subset="none" type="note">
                    <para>
The total length of the pattern is restricted to an engine-specific maximum (a couple of hundred characters are usually accepted).  The pattern should be used to restrict the search to a certain common name or user, not to list many specific keys at once by listing their fingerprints or key IDs.
</para>
                </block>
                <para>
If <paramref name="secretOnly" /> is not <see langword="false" />, the list is restricted to secret keys only.
</para>
            </remarks>
        </member>
        <member name="M:Libgpgme.IKeyStore.GetKeyList(System.String[],System.Boolean)">
            <param name="pattern">An array of <see cref="T:System.String" />. Each string should contain an engine specific expression that is used to limit the list of returned <see cref="C:Libgpgme.Key" /> objects.</param>
            <param name="secretOnly">If <see langword="true" />, the returning list is restricted to secret keys only.</param>
            <summary>Initiates a key listing operation.</summary>
            <returns>An array of <see cref="C:Libgpgme.Key" /> objects. Depending on the engine <see cref="C:Libgpgme.PgpKey" />s or <see cref="C:Libgpgme.X509Key" />s are returned.</returns>
            <remarks>
                <para>
If <paramref name="pattern" /> is <see langword="null" />, all available keys are returned.  Otherwise, <paramref name="pattern" /> contains an array with engine specific expressions that are used to limit the list to all keys matching the pattern.  
</para>
                <block subset="none" type="note">
                    <para>
The total length of the pattern is restricted to an engine-specific maximum (a couple of hundred characters are usually accepted).  The pattern should be used to restrict the search to a certain common name or user, not to list many specific keys at once by listing their fingerprints or key IDs.
</para>
                </block>
                <para>
If <paramref name="secretOnly" /> is not <see langword="false" />, the list is restricted to secret keys only.
</para>
            </remarks>
        </member>
        <member name="M:Libgpgme.IKeyStore.Import(Libgpgme.GpgmeData)">
            <param name="keydata">A <see cref="C:Libgpgme.GpgmeData" /> object that contains the keys.</param>
            <summary>Adds the keys in the user-supplied data buffer to the key ring.</summary>
            <returns>An <see cref="C:Libgpgme.ImportResult" /> object.</returns>
            <remarks>
                <para>
The function adds the keys in the data buffer <paramref name="keydata" /> to the keyring of the keystore. The format of <paramref name="keydata" /> can be ASCII armored, for example, but the details are specific to the used keystore type.
</para>
            </remarks>
        </member>
        <member name="T:Libgpgme.ImportResult">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.Considered">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.Imported">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.ImportedRSA">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.Imports">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.NewRevocations">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.NewSignatures">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.NewSubkeys">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.NewUserIds">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.NotImported">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.NoUserId">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.SecretImported">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.SecretRead">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.SecretUnchanged">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.SkippedNewKeys">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportResult.Unchanged">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.ImportStatus">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportStatus.Fpr">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.ImportStatus.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportStatus.HasNewSignatures">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportStatus.HasNewSubkeys">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportStatus.HasNewUids">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportStatus.NewKey">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportStatus.NewSecretKey">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportStatus.Next">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.ImportStatus.Result">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.ImportStatus.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.ImportStatusFlags">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.ImportStatusFlags.New">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.ImportStatusFlags.Secret">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.ImportStatusFlags.Signature">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.ImportStatusFlags.Subkey">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.ImportStatusFlags.Uid">
            <summary>To be added.</summary>
        </member>
        <member name="T:Libgpgme.InvalidContextException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidContextException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidContextException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.InvalidDataBufferException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidDataBufferException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidDataBufferException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.InvalidHashAlgoException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidHashAlgoException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.InvalidKey">
            <summary>Contains information about an invalid key.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.InvalidKey.Fingerprint">
            <summary>An hexdecimal encoded string of the key's fingerprint.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.InvalidKey.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.InvalidKey.Next">
            <summary>The next invalid recipient key in the list.</summary>
            <value>The next <see cref="C:Libgpgme.InvalidKey" /> in the list.</value>
            <remarks>Is <see langword="null" /> if it is the last key in the list.</remarks>
        </member>
        <member name="P:Libgpgme.InvalidKey.Reason">
            <summary>An integer that contains the reason code.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.InvalidKey.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.InvalidKeyException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidKeyException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidKeyException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.InvalidKeyFprException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidKeyFprException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidKeyFprException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.InvalidPassphraseException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidPassphraseException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidPassphraseException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.InvalidProtocolException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidProtocolException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.InvalidPtrException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidPtrException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.InvalidPubkeyAlgoException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidPubkeyAlgoException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.InvalidTimestampException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidTimestampException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.InvalidTimestampException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.Key">
            <summary>An instance of this class represents a key.</summary>
            <remarks>Currently, <see cref="C:Libgpgme.Key" /> can represent either an S/Mime (X.509) or an OpenPGP key.</remarks>
        </member>
        <member name="P:Libgpgme.Key.CanAuthenticate">
            <summary>Indicates that the key can be used for authentication.</summary>
            <value>Is <see langword="true" /> if the key (ie one of its subkeys) can be used for authentication.
</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Key.CanCertify">
            <summary>Indicates that the key can be used to create key certificates.</summary>
            <value>Is <see langword="true" /> if the key (ie one of its subkeys) can be used to create key certificates.
</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Key.CanEncrypt">
            <summary>Indicates that the key can be used for encryption.</summary>
            <value>Is <see langword="true" /> if the key (ie. one of its subkeys) can be used for encryption.
</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Key.CanSign">
            <summary>Indicates that the key can be used to create data signatures.</summary>
            <value>Is <see langword="true" /> if the key (ie one of its subkeys) can be used to create data signatures.
</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Key.ChainId">
            <summary>The chain ID.</summary>
            <value>A <see cref="T:System.String" />.</value>
            <remarks>If <see cref="P:Libgpgme.Key.Protocol" /> is <see cref="P:Libgpgme.Protocol.CMS" />, then this is the chain ID, which can be used to built the certificate chain.
</remarks>
        </member>
        <member name="P:Libgpgme.Key.Disabled">
            <summary>Indicates that the key has been disabled.</summary>
            <value>Is <see langword="true" /> if the key is disabled.</value>
            <remarks />
        </member>
        <member name="M:Libgpgme.Key.Dispose">
            <summary>Disposes a Key object.</summary>
            <remarks>The internal GPGME reference count of this key will be decremented.</remarks>
        </member>
        <member name="F:Libgpgme.Key.editlock">
            <summary>A lock object used for thread safety.</summary>
            <remarks>Use the lock keyword on this field if your inherited class does (edit-) operations on key.</remarks>
        </member>
        <member name="P:Libgpgme.Key.Expired">
            <summary>Indicates that the key is expired.</summary>
            <value>Is <see langword="true" /> if the key is expired.</value>
            <remarks />
        </member>
        <member name="M:Libgpgme.Key.Finalize">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Key.Fingerprint">
            <summary>The key's fingerprint.</summary>
            <value>A <see cref="T:System.String" /> that contains the (hexdecimal) fingerprint of a key.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Key.Invalid">
            <summary>Indicates that the key is invalid.</summary>
            <value>Is <see langword="true" /> if the key is invalid.</value>
            <remarks>This is <see langword="true" /> if the key is invalid. This might have several reasons, for a example for the S/MIME backend, it will be set in during key listsing if the key could not be validated due to a missing certificates or unmatched policies.
</remarks>
        </member>
        <member name="P:Libgpgme.Key.IsQualified">
            <summary>Indicates that the key can be used for qualified signatures.</summary>
            <value>Is <see langword="true" /> if the key can be used for qualified signatures.
</value>
            <remarks>Is <see langword="true" /> if the key can be used for qualified signatures according to local government regulations.</remarks>
        </member>
        <member name="P:Libgpgme.Key.IssuerName">
            <summary>The issuer name.</summary>
            <value>A <see cref="T:System.String" />.</value>
            <remarks>If <see cref="P:Libgpgme.Key.Protocol" /> is <see cref="P:Libgpgme.Protocol.CMS" />, then this is the issuer name.</remarks>
        </member>
        <member name="P:Libgpgme.Key.IssuerSerial">
            <summary>The the issuer serial.</summary>
            <value>A <see cref="System.String" />.</value>
            <remarks>If <see cref="P:Libgpgme.Key.Protocol" /> is <see cref="P:Libgpgme.Protocol.CMS" />, then this is the issuer serial.
</remarks>
        </member>
        <member name="M:Libgpgme.Key.KeyEditCallback(System.IntPtr,Libgpgme.KeyEditStatusCode,System.String,System.IO.Stream)">
            <param name="handle">A <see cref="T:System.IntPtr" /> handle that was provided by the user at start of operation.</param>
            <param name="status">A <see cref="T:Libgpgme.KeyEditStatusCode" />.</param>
            <param name="args">A <see cref="T:System.String" /> containing the arguments.</param>
            <param name="fd">A <see cref="T:System.IO.Stream" /> used for communication with the engine's key editing procedure.</param>
            <summary>A callback function which GPGME calls if a key edit operation is on-going.</summary>
            <returns>A <see cref="T:System.Integer" />. If the returning value is not 0, the key editing procedure will be stopped. See "Remarks" for more information.</returns>
            <remarks>
                <para>
KeyEditCallback method must be overwritten by the inherited class.
</para>
                <para>
It is the functions which GPGME calls if a key edit operation is on-going. The status code <paramref name="status" /> and the argument line <paramref name="args" /> are passed through by GPGME from the crypto engine. The Stream <paramref name="fd" /> is <see langword="null" /> for normal status messages.  
</para>
                <para>
If <paramref name="status" /> indicates a command rather than a status message, the response to the command should be written to <paramref name="fd" />. The <paramref name="handle" /> was provided by the user at start of operation <see cref="M:Libgpgme.Key.StartEdit(Libgpgme.Context,System.IntPtr,Libgpgme.GpgmeData)" />.
</para>
                <para>
The function should return 0 or an error value. If the returning value is not 0, GPGME will stop the key editing procedure and an error will be thrown.
</para>
                <para>
If the KeyEditCallback method of the inherited class throws an exception during the callback, it will be saved in the <see cref="P:Libgpgme.Key.LastCallbackException" /> attribute.
</para>
            </remarks>
        </member>
        <member name="P:Libgpgme.Key.KeyId">
            <summary>The key ID.</summary>
            <value>A <see cref="T:System.String" /> that contains the (hexdecimal) key id.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Key.KeylistMode">
            <summary>The keylist mode that was active when the key was retrieved.</summary>
            <value>A bit-vector if the <see cref="T:Libgpgme.KeylistMode" /> that was active when the key was retrieved.</value>
            <remarks>You can change the <see cref="T:Libgpgme.KeylistMode" /> of the context by using the <see cref="P:Libgpgme.Context.KeyListMode" /> property.</remarks>
        </member>
        <member name="F:Libgpgme.Key.LastCallbackException">
            <summary>The last exception that occurred during a key-edit operation.</summary>
            <remarks>Some key types allow operation on the key itself (e.g. editing). If the underlying crypto backend throws an error, this property is set.</remarks>
        </member>
        <member name="P:Libgpgme.Key.OwnerTrust">
            <summary>The owner trust.</summary>
            <value>A <see cref="T:Libgpgme.Validity" /> value.</value>
            <remarks>If <see cref="P:Libgpgme.Key.Protocol" /> is <see cref="P:Libgpgme.Protocol.OpenPGP" />, then this is the owner trust.
</remarks>
        </member>
        <member name="P:Libgpgme.Key.Protocol">
            <summary>This is the protocol supported by this key.</summary>
            <value>The <see cref="C:Libgpgme.Protocol" /> supported by this key.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Key.Revoked">
            <summary>Indicates that the key has been revoked.</summary>
            <value>Is <see langword="true" /> if the key is revoked.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Key.Secret">
            <summary>Indicates that the key is a secret key. </summary>
            <value>Is true if the key is a secret key.  
</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
This will always be <see langword="true" /> even if the corresponding subkey flag may be <see langword="false" /> (offline/stub keys).
  </para>
                </block>
            </remarks>
        </member>
        <member name="M:Libgpgme.Key.StartEdit(Libgpgme.Context,System.IntPtr,Libgpgme.GpgmeData)">
            <param name="ctx">A <see cref="C:Libgpgme.Context" /> used for the editing operation.</param>
            <param name="handle">A <see cref="T:System.IntPtr" /> value (handle) that can be used to identify callback calls from GPGME.</param>
            <param name="data">A <see cref="C:Libgpgme.GpgmeData" /> object.</param>
            <summary>Starts the key editing operation.</summary>
            <returns>A <see cref="T:System.Int32" /> containing an error value. Is 0 if the operation completed successfully.</returns>
            <remarks>A class that is inherited from <see cref="C:Libgpgme.Key" /> can call this method in order to start a key editing operation. In this case, the <see cref="M:Libgpgme.Key.KeyEditCallback(IntPtr,Libgpgme.KeyEditStatusCode,System.String,System.IO.Stream)" /> method MUST be overwritten by the inherited class.</remarks>
        </member>
        <member name="P:Libgpgme.Key.Subkeys">
            <summary>The subkeys of the key.</summary>
            <value>The first <see cref="C:Libgpgme.Subkey" /> in the list. <see langword="null" /> if no subkeys are available.</value>
            <remarks>
                <para>
This is a linked list with the subkeys of the key.  The first subkey in the list is the primary key and usually available.
</para>
                <para>
You can enumerate the linked list with the subkey's <see cref="P:Libgpgme.Subkey.Next" /> property or by using the <see cref="M:Libgpgme.Subkey.GetEnumerator()" /> method.
</para>
            </remarks>
        </member>
        <member name="P:Libgpgme.Key.Uid">
            <summary>The primary user ID of a key.</summary>
            <value>The first <see cref="C:Libgpgme.UserId" /> in the list. <see langword="null" /> if no user ID information available.</value>
            <remarks>This property is a reference to <see cref="P:Libgpgme.Key.Uids" />.
</remarks>
        </member>
        <member name="P:Libgpgme.Key.Uids">
            <summary>The user IDs of the key.</summary>
            <value>The first <see cref="C:Libgpgme.UserId" /> in the list. <see langword="null" /> if no user IDs are available.</value>
            <remarks>
                <para>
This is a linked list with the user IDs of the key.  The first user ID in the list is the main (or primary) user ID.
</para>
                <para>
You can enumerate the linked list with the user ID's <see cref="P:Libgpgme.UserId.Next" /> property or by using the <see cref="M:Libgpgme.UserId.GetEnumerator()" /> method.
</para>
            </remarks>
        </member>
        <member name="T:Libgpgme.KeyAlgorithm">
            <summary>Specifies the set of all public key algorithms that are supported by GPGME.</summary>
            <remarks>Public key algorithms are used for encryption, decryption, signing and verification of signatures.
</remarks>
        </member>
        <member name="F:Libgpgme.KeyAlgorithm.DSA">
            <summary>This value indicates DSA, the Digital Signature Algorithm.</summary>
        </member>
        <member name="F:Libgpgme.KeyAlgorithm.ELG">
            <summary>This value indicates ElGamal.</summary>
        </member>
        <member name="F:Libgpgme.KeyAlgorithm.ELG_E">
            <summary>This value also indicates ElGamal and is used specifically in GnuPG.
</summary>
        </member>
        <member name="F:Libgpgme.KeyAlgorithm.RSA">
            <summary>This value indicates the RSA (Rivest, Shamir, Adleman) algorithm.
</summary>
        </member>
        <member name="F:Libgpgme.KeyAlgorithm.RSA_E">
            <summary>This value indicates the RSA (Rivest, Shamir, Adleman) algorithm for encryption and decryption only.
<block subset="none" type="note"><para>
Deprecated. Use <see cref="F:Libgpgme.KeyAlgorithm.RSA" /> and set the appropriate capabilities when creating new keys.
  </para></block></summary>
        </member>
        <member name="F:Libgpgme.KeyAlgorithm.RSA_S">
            <summary>This value indicates the RSA (Rivest, Shamir, Adleman) algorithm for signing and verification only.
<block subset="none" type="note"><para>
Deprecated. Use <see cref="F:Libgpgme.KeyAlgorithm.RSA" /> and set the appropriate capabilities when creating new keys.
  </para></block></summary>
        </member>
        <member name="T:Libgpgme.KeyConflictException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.KeyConflictException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.KeyConflictException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.KeyEditStatusCode">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.Abort">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.AlreadySigned">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.BackupKeyCreated">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.BadArmor">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.BadMDC">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.BadPassphrase">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.BadSignature">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.BeginDecryption">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.BeginEncryption">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.BeginStream">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.Cardctrl">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.DecryptionFailed">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.DecryptionOkay">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.DeleteProblem">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.EncryptedTo">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.EndDecryption">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.EndEncryption">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.EndStream">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.Enter">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.Eof">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.Error">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.ErrorMDC">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.ErrorSignature">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.ExpiredKeySignature">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.ExpiredSignature">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.FileDone">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.FileError">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.FileStart">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.GetBool">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.GetHidden">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.GetLine">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.GoodMDC">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.GoodPassphrase">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.GoodSignature">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.GotIt">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.Imported">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.ImportOk">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.ImportProblem">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.ImportRes">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.InvalidRecipient">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.KeyCreated">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.KeyExpired">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.KeyRevoked">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.Leave">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.MissingPassphrase">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.NeedPassphrase">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.NeedPassphrasePin">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.NeedPassphraseSym">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.NewSignature">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.NoData">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.NoPublicKey">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.NoRecipient">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.NoSecretKey">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.NotationData">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.NotationName">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.PKATrustBad">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.PKATrustGood">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.PlainText">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.PolicyURL">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.Progress">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.RevKeySignature">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.RSAorIDEA">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.SCOperationFailure">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.SCOperationSuccess">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.SessionKey">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.SHMGet">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.SHMGetBool">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.SHMGetHidden">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.SHMInfo">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.SignatureCreated">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.SignatureExpired">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.SignatureId">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.SignedSubPacket">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.Truncated">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.TrustFully">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.TrustMarginal">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.TrustNever">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.TrustUltimate">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.TrustUndefined">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.Unexpected">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.UserIdHint">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.KeyEditStatusCode.ValidSignature">
            <summary>To be added.</summary>
        </member>
        <member name="T:Libgpgme.KeyExportException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.KeyExportException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.KeyExportException(System.String,System.Int32)">
            <param name="message">To be added.</param>
            <param name="GPGMEError">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.KeyImportException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.KeyImportException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.KeyImportException(System.String,System.Int32)">
            <param name="message">To be added.</param>
            <param name="GPGMEError">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.KeylistMode">
            <summary>This type's values change the behaviour of the key listing methods.</summary>
            <remarks>At least one of <see cref="P:Libgpgme.KeylistMode.Local" /> and <see cref="P:Libgpgme.KeylistMode.Extern" /> must be specified.</remarks>
        </member>
        <member name="F:Libgpgme.KeylistMode.Extern">
            <summary>This symbol specifies that an external source should be searched for keys in the keylisting operation.  The type of external source is dependant on the crypto engine used.  For example, it can be a remote keyserver or LDAP certificate server.
</summary>
        </member>
        <member name="F:Libgpgme.KeylistMode.Local">
            <summary> This symbol specifies that the local keyring should be searched for keys in the keylisting operation.  
<block subset="none" type="note"><para>
This is the default.
  </para></block></summary>
        </member>
        <member name="F:Libgpgme.KeylistMode.SignatureNotations">
            <summary>This symbol specifies that the signature notations on key signatures should be included in the listed keys.  This only works if <see cref="P:Libgpgme.KeylistMode.Signatures" /> is also enabled.
</summary>
        </member>
        <member name="F:Libgpgme.KeylistMode.Signatures">
            <summary>This symbol specifies that the key signatures should be included in the listed keys.
</summary>
        </member>
        <member name="F:Libgpgme.KeylistMode.Validate">
            <summary>This symbol specifies that the  backend should do key or certificate validation and not just get the validity information from an internal cache.  This might be an expensive operation and is in general not useful. Currently only implemented for the S/MIME backend and ignored for other backends.
</summary>
        </member>
        <member name="T:Libgpgme.KeyNotFoundException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.KeyNotFoundException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.KeyNotFoundException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.KeyParameters">
            <summary>A class used to store parameters for new key pairs.</summary>
            <remarks />
        </member>
        <member name="C:Libgpgme.KeyParameters">
            <summary>Creates a new KeyParameters instance.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeyParameters.AutoKeyUsage">
            <summary>Indicates if the algorithm capabilities shall be adjusted automatically.</summary>
            <value>A <see cref="T:System.Boolean" />.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeyParameters.Comment">
            <summary>A key comment.</summary>
            <value>A <see cref="T:System.String" />.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeyParameters.Email">
            <summary>An email address.</summary>
            <value>A <see cref="T:System.String" />.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeyParameters.ExpirationDate">
            <summary>The expiration date of the key.</summary>
            <value>A <see cref="T:System.DateTime" />.</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
Depending on your timezone you might see the date 1970-01-01 UTC. This special date is used to mark a key to never expire.
You can unset the expiration date with the <see cref="M:Libgpgme.KeyParameters.MakeInfinitely()" /> method. 
  </para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.KeyParameters.IsInfinitely">
            <summary>Indicates that the key does not expire.</summary>
            <value>A <see cref="T:System.Boolean" />.</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
You can unset the expiration date with the <see cref="M:Libgpgme.KeyParameters.MakeInfinitely()" /> method.
  </para>
                </block>
            </remarks>
        </member>
        <member name="F:Libgpgme.KeyParameters.KEY_LENGTH_1024">
            <summary>1024 bits key size.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.KeyParameters.KEY_LENGTH_2048">
            <summary>2048 bits key size.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.KeyParameters.KEY_LENGTH_4096">
            <summary>4096 bits key size.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeyParameters.KeyLength">
            <summary>The key length in bits.</summary>
            <value>A <see cref="T:System.Int32" />.</value>
            <remarks>
                <para>
You can use the following constant values:
</para>
                <list type="table">
                    <listheader>
                        <term>Constant</term>
                        <description>Description</description>
                    </listheader>
                    <item>
                        <term>
                            <see cref="F:Libgpgme.KeyParameters.KEY_LENGTH_1024" />
                        </term>
                        <description>for 1024 bits key length</description>
                    </item>
                    <item>
                        <term>
                            <see cref="F:Libgpgme.KeyParameters.KEY_LENGTH_2048" />
                        </term>
                        <description>for 2048 bits key length</description>
                    </item>
                    <item>
                        <term>
                            <see cref="F:Libgpgme.KeyParameters.KEY_LENGTH_4096" />
                        </term>
                        <description>for 4096 bits key length</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:Libgpgme.KeyParameters.MakeInfinitely">
            <summary>Sets the key to never expire.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeyParameters.NameDN">
            <summary>The name DN.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.KeyParameters.NoSubkey">
            <summary>Indicates if only the primary key should be created.</summary>
            <value>A <see cref="T:System.Boolean" />.</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
This is only valid for OpenPGP keys.
  </para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.KeyParameters.Passphrase">
            <summary>The passphrase of the new key.</summary>
            <value>A <see cref="T:System.String" />.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeyParameters.PubkeyAlgorithm">
            <summary>The public key algorithm.</summary>
            <value>A <see cref="T:Libgpgme.KeyAlgorithm" />.</value>
            <remarks>
                <para>
The primary key algorithm MUST have the <see cref="F:Libgpgme.AlgorithmCapability.CanSign" /> capability. The <see cref="F:Libgpgme.AlgorithmCapability.CanCert" /> capability will be added automatically. You can modify the capabilities with the <see cref="P:Libgpgme.KeyParameters.PubkeyUsage" /> property.
</para>
                <block subset="none" type="note">
                    <para>
The following public key algorithms are valid for the primary key when creating OpenPGP keys:
  </para>
                    <para>
                        <list type="table">
                            <listheader>
                                <term>Algorithm</term>
                                <description>Description</description>
                            </listheader>
                            <item>
                                <term>
                                    <see cref="F:Libgpgme.KeyAlgorithm.DSA" />
                                </term>
                                <description>DSA</description>
                            </item>
                            <item>
                                <term>
                                    <see cref="F:Libgpgme.KeyAlgorithm.RSA" />
                                </term>
                                <description>RSA (you need to add the <see cref="F:Libgpgme.AlgorithmCapability.CanSign" /> capability)</description>
                            </item>
                        </list>
                    </para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.KeyParameters.PubkeyLength">
            <summary>The public key length in bits.</summary>
            <value>A <see cref="T:System.Int32" />.</value>
            <remarks>
                <para>
You can use the following constant values:
</para>
                <list type="table">
                    <listheader>
                        <term>Constant</term>
                        <description>Description</description>
                    </listheader>
                    <item>
                        <term>
                            <see cref="F:Libgpgme.KeyParameters.KEY_LENGTH_1024" />
                        </term>
                        <description>for 1024 bits key length</description>
                    </item>
                    <item>
                        <term>
                            <see cref="F:Libgpgme.KeyParameters.KEY_LENGTH_2048" />
                        </term>
                        <description>for 2048 bits key length</description>
                    </item>
                    <item>
                        <term>
                            <see cref="F:Libgpgme.KeyParameters.KEY_LENGTH_4096" />
                        </term>
                        <description>for 4096 bits key length</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="P:Libgpgme.KeyParameters.PubkeyUsage">
            <summary>The algorithm capabilities of the primary key.</summary>
            <value>A bit-vector <see cref="T:Libgpgme.AlgorithmCapability" />.</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
When using OpenPGP, the primary key MUST have the <see cref="F:Libgpgme.AlgorithmCapability.CanSign" /> capability. The <see cref="F:Libgpgme.AlgorithmCapability.CanCert" /> capability will be added automatically.
  </para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.KeyParameters.RealName">
            <summary>The real name.</summary>
            <value>A <see cref="T:System.String" />.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeyParameters.SubkeyAlgorithm">
            <summary>The subkey algorithm.</summary>
            <value>A <see cref="T:Libgpgme.KeyAlgorithm" />.</value>
            <remarks>
                <para>
You can modify the capabilities with the <see cref="P:Libgpgme.KeyParameters.SubkeyUsage" /> property.
</para>
                <block subset="none" type="note">
                    <para>
The following public key algorithms are valid for the subkey when creating OpenPGP keys:
  </para>
                    <para>
                        <list type="table">
                            <listheader>
                                <term>Algorithm</term>
                                <description>Description</description>
                            </listheader>
                            <item>
                                <term>
                                    <see cref="F:Libgpgme.KeyAlgorithm.DSA" />
                                </term>
                                <description>DSA</description>
                            </item>
                            <item>
                                <term>
                                    <see cref="F:Libgpgme.KeyAlgorithm.RSA" />
                                </term>
                                <description>RSA</description>
                            </item>
                            <item>
                                <term>
                                    <see cref="F:Libgpgme.KeyAlgorithm.ELG_E" />
                                </term>
                                <description>ELG_E</description>
                            </item>
                        </list>
                    </para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.KeyParameters.SubkeyLength">
            <summary>The subkey length in bits.</summary>
            <value>A <see cref="T:System.Int32" />.</value>
            <remarks>
                <para>
You can use the following constant values:
</para>
                <list type="table">
                    <listheader>
                        <term>Constant</term>
                        <description>Description</description>
                    </listheader>
                    <item>
                        <term>
                            <see cref="F:Libgpgme.KeyParameters.KEY_LENGTH_1024" />
                        </term>
                        <description>for 1024 bits key length</description>
                    </item>
                    <item>
                        <term>
                            <see cref="F:Libgpgme.KeyParameters.KEY_LENGTH_2048" />
                        </term>
                        <description>for 2048 bits key length</description>
                    </item>
                    <item>
                        <term>
                            <see cref="F:Libgpgme.KeyParameters.KEY_LENGTH_4096" />
                        </term>
                        <description>for 4096 bits key length</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="P:Libgpgme.KeyParameters.SubkeyUsage">
            <summary>The algorithm capabilities of the subkey.</summary>
            <value>A bit-vector <see cref="T:Libgpgme.AlgorithmCapability" />.</value>
            <remarks />
        </member>
        <member name="T:Libgpgme.KeyPreferences">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.KeyPreferences">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.KeyPreferences.Ciphers">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.KeyPreferences.Compress">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.KeyPreferences.GetPrefString">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.KeyPreferences.Hashes">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.KeyPreferences.PGPFeatures">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.KeySignature">
            <summary>A class that contains information about a key signature.</summary>
            <remarks>
                <para>
Key signatures are one component of a <see cref="C:Libgpgme.Key" /> object, and validate user IDs (<see cref="C:Libgpgme.UserId" />) on the key. You can enumerate all key signatures by using the <see cref="P:Libgpgme.KeySignature.Next" /> property or the <see cref="M:Libgpgme.KeySignature.GetEnumerator()" /> method.
</para>
                <block subset="none" type="note">
                    <para>
The signatures on a key are only available if the key was retrieved via a listing operation with the <see cref="F:Libgpgme.KeylistMode.Signatures" /> flag enabled (see <see cref="P:Libgpgme.Context.KeylistMode" />), because it can be expensive to retrieve all signatures of a key.
</para>
                    <para>
The signature notations on a key signature are only available if the key was retrieved via a listing operation with the <see cref="F:Libgpgme.KeylistMode.SignatureNotations" /> flag enabled (see <see cref="P:Libgpgme.Context.KeylistMode" />), because it can be expensive to retrieve all signature notations.
  </para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.KeySignature.Comment">
            <summary>The comment component of Uid, if available.</summary>
            <value>A <see cref="T:System.String" /> containing the comment component of <see cref="P:Libgpgme.KeySignature.Uid" />, if available.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeySignature.Email">
            <summary>The email component of Uid, if available.</summary>
            <value>A <see cref="T:System.String" /> containing the email component of <see cref="P:Libgpgme.KeySignature.Uid" />, if available.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeySignature.Expired">
            <summary>Indicates that the key signature is expired.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the key signature is expired.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeySignature.Expires">
            <summary>The expiration timestamp of the key signature.</summary>
            <value>A <see cref="T:System.DateTime" /> containing the expiration timestamp of the key signature.</value>
            <remarks>Always check the <see cref="P:Libgpgme.KeySignature.IsInfinitely" /> property in order to find out whether the key signature can expire. If the signature cannot expire, <see cref="P:Libgpgme.KeySignature.Expires" /> contains an invalid value (Depending on your timezone you might see the date 1970-01-01 UTC).</remarks>
        </member>
        <member name="P:Libgpgme.KeySignature.ExpiresUTC">
            <summary>The expiration timestamp of the key signature in UTC.</summary>
            <value>A <see cref="T:System.DateTime" /> containing the expiration timestamp of the key signature in UTC.</value>
            <remarks>Always check the <see cref="P:Libgpgme.KeySignature.IsInfinitely" /> property in order to find out whether the key signature can expire. If the signature cannot expire, <see cref="P:Libgpgme.KeySignature.Expires" /> contains an invalid value (Depending on your timezone you might see the date 1970-01-01 UTC).</remarks>
        </member>
        <member name="P:Libgpgme.KeySignature.Exportable">
            <summary>Indicates that the key signature is exportable.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the key signature is exportable.</value>
            <remarks />
        </member>
        <member name="M:Libgpgme.KeySignature.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.KeySignature.Invalid">
            <summary>Indicates that the key signature is invalid.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the key signature is invalid.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeySignature.IsInfinitely">
            <summary>Indicates that the key signature does not expire.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the key signature does not expire.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeySignature.KeyId">
            <summary>The key ID of the key used to create the signature.</summary>
            <value>A <see cref="T:System.String" /> containing the key ID of the key used to create the signature in hexadecimal digits.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeySignature.Name">
            <summary>The name component of Uid, if available.</summary>
            <value>A <see cref="T:System.String" /> containing the name component of <see cref="P:Libgpgme.KeySignature.Uid" />, if available.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeySignature.Next">
            <summary>The next key signature object.</summary>
            <value>The next <see cref="C:Libgpgme.KeySignature" /> object in the linked list, or <see langword="null" /> if this is the last element.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeySignature.Notations">
            <summary>A linked list with the notation data and policy URLs.</summary>
            <value>A <see cref="C:Libgpgme.SignatureNotation" /> object.</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
The signature notations on a key signature are only available if the key was retrieved via a listing operation with the <see cref="F:Libgpgme.KeylistMode.SignatureNotations" /> flag enabled (see <see cref="P:Libgpgme.Context.KeylistMode" />), because it can be expensive to retrieve all signature notations.
  </para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.KeySignature.PubkeyAlgorithm">
            <summary>The public key algorithm used to create the signature.</summary>
            <value>A <see cref="T:Libgpgme.KeyAlgorithm" />.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeySignature.Revoked">
            <summary>Indicates that this key signature is a revocation signature.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the key signature is a revocation signature.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.KeySignature.SigClass">
            <summary>The signature class of the key signature</summary>
            <value>A <see cref="T:System.Int64" />.</value>
            <remarks>This specifies the signature class of the key signature. The meaning is specific to the crypto engine.
</remarks>
        </member>
        <member name="P:Libgpgme.KeySignature.Status">
            <summary>The status of the key signature.</summary>
            <value>A <see cref="T:System.Int32" />.</value>
            <remarks>This is the status of the signature and has the same meaning as the member of the same name in a <see cref="C:Libgpgme.Signature" /> object.
</remarks>
        </member>
        <member name="M:Libgpgme.KeySignature.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.KeySignature.Timestamp">
            <summary>The creation timestamp of the key signature.</summary>
            <value>A <see cref="T:System.DateTime" /> containing the creation timestamp of the key signature.
</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
A <see cref="C:Libgpgme.InvalidTimestampException" /> will be raised if the timestamp is invalid. A <see cref="C:Libgpgme.TimestampNotAvailableException" /> will be raised if the timestamp is not available.
</para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.KeySignature.TimestampUTC">
            <summary>The creation timestamp of the key signature in UTC.</summary>
            <value>A <see cref="T:System.DateTime" /> containing the creation timestamp of the key signature in UTC.
</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
A <see cref="C:Libgpgme.InvalidTimestampException" /> will be raised if the timestamp is invalid. A <see cref="C:Libgpgme.TimestampNotAvailableException" /> will be raised if the timestamp is not available.
</para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.KeySignature.Uid">
            <summary>The main user ID of the key used to create the signature.</summary>
            <value>A <see cref="T:System.String" /> containing the main user ID of the key used to create this signature.</value>
            <remarks />
        </member>
        <member name="T:Libgpgme.KeyStore">
            <summary>A class that represents the default key store.</summary>
            <remarks>
                <para>
The most cryptographic operations require that recipients or signers are specified.  This is always done by specifying the respective keys that should be used for the operation. A KeyStore that implements <see cref="T:Libgpgme.IKeyStore" /> provides all methods needed to import, export, delete and enumerate such keys. Furthermore if it implements <see cref="T:Libgpgme.IKeyGenerator" /> it can be used to generate new keys as well.
</para>
You can use the <see cref="P:Libgpgme.Context.KeyStore" /> property to receive an engine-specific default key store object.</remarks>
        </member>
        <member name="C:Libgpgme.KeyStore(Libgpgme.Context)">
            <param name="ctx">A <see cref="C:Libgpgme.Context" /> that used to retrieve the default key store from.
<block subset="none" type="note"><para>
It will use the engine to which the context's <see cref="P:Libgpgme.Context.Protocol" /> property refers to.
  </para></block></param>
            <summary>Creates a new KeyStore object.</summary>
            <remarks>You can use the <see cref="P:Libgpgme.Context.KeyStore" /> property to receive an engine-specific default key store object.</remarks>
        </member>
        <member name="P:Libgpgme.KeyStore.Context">
            <summary>The context that was used to retrieve the engine-specific key store.</summary>
            <value>A <see cref="C:Libgpgme.Context" /> object.</value>
            <remarks>The <see cref="P:Libgpgme.Context.Protocol" /> property refers to the currently used engine.</remarks>
        </member>
        <member name="M:Libgpgme.KeyStore.DeleteKey(Libgpgme.Key,System.Boolean)">
            <param name="key">The <see cref="C:Libgpgme.Key" /> that shall be deleted from the store.</param>
            <param name="deleteSecret">If <see langword="true" /> the secret key will be deleted as well.</param>
            <summary>Can be used to delete a specific key from the store.</summary>
            <remarks>The function deletes the key <paramref name="key" /> from the keyring.  If <paramref name="deleteSecret" /> is <see langword="false" />, only public keys are deleted, otherwise secret keys are deleted as well, if that is supported.
</remarks>
        </member>
        <member name="M:Libgpgme.KeyStore.Export(System.String,Libgpgme.GpgmeData)">
            <param name="pattern">A <see cref="T:System.String" /> containing an engine specific expression that is used to limit the list of returned keys.</param>
            <param name="keydata">A destination <see cref="C:Libgpgme.GpgmeData" /> buffer.</param>
            <summary>Extracts public keys and returns them in a user-supplied data buffer.</summary>
            <remarks>
                <para>
The function extracts public keys and returns them in the data buffer <paramref name="keydata" />. The output format of the key data returned is determined by the ASCII armor attribute set for the context (see <see cref="P:Libgpgme.Context.Armor" />).
</para>
                <para>
If <paramref name="pattern" /> is <see langword="null" />, all available keys are returned.  Otherwise, <paramref name="pattern" /> contains an engine specific expression that is used to limit the list to all keys matching the pattern.
</para>
            </remarks>
        </member>
        <member name="M:Libgpgme.KeyStore.Export(System.String[],Libgpgme.GpgmeData)">
            <param name="pattern">An array of <see cref="T:System.String" />s, each containing an engine specific expression that is used to limit the list of returned keys.</param>
            <param name="keydata">A destination <see cref="C:Libgpgme.GpgmeData" /> buffer.</param>
            <summary>Extracts public keys and returns them in a user-supplied data buffer.</summary>
            <remarks>
                <para>
The function extracts public keys and returns them in the data buffer <paramref name="keydata" />. The output format of the key data returned is determined by the ASCII armor attribute set for the context (see <see cref="P:Libgpgme.Context.Armor" />).
</para>
                <para>
If <paramref name="pattern" /> is <see langword="null" />, all available keys are returned.  Otherwise, <paramref name="pattern" /> contains an array of engine specific expressions that are used to limit the list to all keys matching the pattern.
</para>
            </remarks>
        </member>
        <member name="M:Libgpgme.KeyStore.GenerateKey(Libgpgme.Protocol,Libgpgme.KeyParameters)">
            <param name="protocoltype">A <see cref="T:Libgpgme.Protocol" /> the specifies the type of the new key pairs.</param>
            <param name="keyparms">A <see cref="C:Libgpgme.KeyParameters" /> object.</param>
            <summary>Generates a new key and adds it to the store.</summary>
            <returns>A <see cref="C:Libgpgme.GenkeyResult" /> object that contains information about a new generated key pairs. </returns>
            <remarks>
                <block subset="none" type="note">
                    <para>
Currently only the OpenPGP protocol is supported.
</para>
                </block>
            </remarks>
        </member>
        <member name="M:Libgpgme.KeyStore.GetKey(System.String,System.Boolean)">
            <param name="fpr">A <see cref="T:System.String" /> containing the fingerprint (or key ID) of the requested key.</param>
            <param name="secretOnly">If <see langword="true" />, get the secret key.</param>
            <summary>Can be used to retrieve a single key.</summary>
            <returns>A <see cref="C:Libgpgme.Key" /> object. Depending on the engine a <see cref="C:Libgpgme.PgpKey" /> or <see cref="C:Libgpgme.X509Key" /> is returned.</returns>
            <remarks>GPGME holds a reference to the returned <see cref="C:Libgpgme.Key" /> object as long as the key instance did not get garbage collected or got disposed.</remarks>
        </member>
        <member name="M:Libgpgme.KeyStore.GetKeyList(System.String,System.Boolean)">
            <param name="pattern">A <see cref="T:System.String" /> containing an engine specific expression that is used to limit the list of returned <see cref="C:Libgpgme.Key" /> objects.</param>
            <param name="secretOnly">If <see langword="true" />, the returning list is restricted to secret keys only.</param>
            <summary>Initiates a key listing operation.</summary>
            <returns>An array of <see cref="C:Libgpgme.Key" /> objects. Depending on the engine <see cref="C:Libgpgme.PgpKey" />s or <see cref="C:Libgpgme.X509Key" />s are returned.</returns>
            <remarks>
                <para>
If <paramref name="pattern" /> is <see langword="null" />, all available keys are returned.  Otherwise, <paramref name="pattern" /> contains an engine specific expression that is used to limit the list to all keys matching the pattern.  
</para>
                <block subset="none" type="note">
                    <para>
The total length of the pattern is restricted to an engine-specific maximum (a couple of hundred characters are usually accepted).  The pattern should be used to restrict the search to a certain common name or user, not to list many specific keys at once by listing their fingerprints or key IDs.
</para>
                </block>
                <para>
If <paramref name="secretOnly" /> is not <see langword="false" />, the list is restricted to secret keys only.
</para>
                <para>
The <see cref="P:Libgpgme.KeyStore.Context" /> (context to which the KeyStore object is attached to) will be busy until all keys are received.
</para>
            </remarks>
        </member>
        <member name="M:Libgpgme.KeyStore.GetKeyList(System.String[],System.Boolean)">
            <param name="pattern">An array of <see cref="T:System.String" />. Each string should contain an engine specific expression that is used to limit the list of returned <see cref="C:Libgpgme.Key" /> objects.</param>
            <param name="secretOnly">If <see langword="true" />, the returning list is restricted to secret keys only.</param>
            <summary>Initiates a key listing operation.</summary>
            <returns>An array of <see cref="C:Libgpgme.Key" /> objects. Depending on the engine <see cref="C:Libgpgme.PgpKey" />s or <see cref="C:Libgpgme.X509Key" />s are returned.</returns>
            <remarks>
                <para>
If <paramref name="pattern" /> is <see langword="null" />, all available keys are returned.  Otherwise, <paramref name="pattern" /> contains an array with engine specific expressions that are used to limit the list to all keys matching the pattern.  
</para>
                <block subset="none" type="note">
                    <para>
The total length of the pattern is restricted to an engine-specific maximum (a couple of hundred characters are usually accepted).  The pattern should be used to restrict the search to a certain common name or user, not to list many specific keys at once by listing their fingerprints or key IDs.
</para>
                </block>
                <para>
If <paramref name="secretOnly" /> is not <see langword="false" />, the list is restricted to secret keys only.
</para>
                <para>
The <see cref="P:Libgpgme.KeyStore.Context" /> (context to which the KeyStore object is attached to) will be busy until all keys are received.
</para>
            </remarks>
        </member>
        <member name="M:Libgpgme.KeyStore.GetTrustList(System.String,System.Int32)">
            <param name="pattern">To be added.</param>
            <param name="maxlevel">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.KeyStore.Import(Libgpgme.GpgmeData)">
            <param name="keydata">A <see cref="C:Libgpgme.GpgmeData" /> object that contains the keys.</param>
            <summary>Adds the keys in the user-supplied data buffer to the key ring.</summary>
            <returns>An <see cref="C:Libgpgme.ImportResult" /> object.</returns>
            <remarks>
                <para>
The function adds the keys in the data buffer <paramref name="keydata" /> to the key ring of the crypto engine used by <see cref="P:Libgpgme.KeyStore.Context" />. The format of <paramref name="keydata" /> can be ASCII armored, for example, but the details are specific to the crypto engine.
</para>
            </remarks>
        </member>
        <member name="T:Libgpgme.NewSignature">
            <summary>Contains information about a new created signature.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.NewSignature.Fingerprint">
            <summary>An hexdecimal encoded <see langword="string" /> of the key's fingerprint which was used to create this signature.
</summary>
            <value />
            <remarks />
        </member>
        <member name="M:Libgpgme.NewSignature.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.NewSignature.HashAlgorithm">
            <summary>The hash algorithm used to create this signature.</summary>
            <value />
            <remarks />
        </member>
        <member name="P:Libgpgme.NewSignature.Next">
            <summary>This is a reference to the next <see cref="T:Libgpgme.NewSignature" /> object in the linked list, or <see langword="null" /> if this is the last element.</summary>
            <value />
            <remarks />
        </member>
        <member name="P:Libgpgme.NewSignature.PubkeyAlgorithm">
            <summary>The public key algorithm used to create this signature.</summary>
            <value />
            <remarks />
        </member>
        <member name="P:Libgpgme.NewSignature.SignatureClass">
            <summary>The signature class of this signature.</summary>
            <value />
            <remarks />
        </member>
        <member name="M:Libgpgme.NewSignature.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.NewSignature.Timestamp">
            <summary>The creation timestamp of this signature.</summary>
            <value />
            <remarks>The timestamp is in local time.</remarks>
        </member>
        <member name="P:Libgpgme.NewSignature.TimestampUTC">
            <summary>The creation timestamp of this signature.</summary>
            <value />
            <remarks>The timestamp is in UTC time.</remarks>
        </member>
        <member name="P:Libgpgme.NewSignature.Type">
            <summary>The type of this signature.</summary>
            <value />
            <remarks />
        </member>
        <member name="T:Libgpgme.NoDataException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.NoDataException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.NoDataException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.NoDataException(System.String,Libgpgme.VerificationResult)">
            <param name="message">To be added.</param>
            <param name="rst">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.NoDataException.VerifyResult">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.PassphraseDelegate">
            <param name="ctx">The context that initiates the passphrase callback.</param>
            <param name="info">A <see cref="C:Libgpgme.PassphraseInfo" /> object that gives an indication for which user ID the passphrase is required.</param>
            <param name="passphrase">The returning passphrase. </param>
            <summary>The type of method that usable as passphrase callback function.</summary>
            <value>Returns a <see cref="T:Libgpgme.PassphraseResult" /> value that indicates success or a user canceled action.</value>
            <remarks>The <see cref="C:Libgpgme.PassphraseInfo" /> object will be <see langword="null" /> in the case of symmetric encryption.

<block subset="none" type="note"><para>
Make sure that you overwrite (wipe) the user's passphrase in memory. You should not use the <see cref="M:System.String.ToArray()" /> method to convert a user supplied string if you do not hold any further reference to it. The callback will NOT wipe the char array after usage.
  </para></block></remarks>
        </member>
        <member name="T:Libgpgme.PassphraseInfo">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.PassphraseInfo.HintText">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.PassphraseInfo.Hook">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.PassphraseInfo.Info">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.PassphraseInfo.KeyLength">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.PassphraseInfo.MainKeyId">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.PassphraseInfo.PrevWasBad">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.PassphraseInfo.PubkeyAlgorithm">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.PassphraseInfo.RequestKeyId">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.PassphraseInfo.Uid">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.PassphraseInfo.UidKeyId">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.PassphraseResult">
            <summary>The result of a passphrase callback.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.PassphraseResult.Canceled">
            <summary>The user has canceled the passphrase entry.</summary>
        </member>
        <member name="F:Libgpgme.PassphraseResult.Success">
            <summary>The user supplied a passphrase.</summary>
        </member>
        <member name="T:Libgpgme.PgpDeleteSignatureOptions">
            <summary>A class that contains information for the (key-) signature deletion operation.</summary>
            <remarks />
        </member>
        <member name="C:Libgpgme.PgpDeleteSignatureOptions">
            <summary>Creates a new instance.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.PgpDeleteSignatureOptions.DeleteSelfSignature">
            <summary>Indicates that GPG is allowed to delete a Self-Signature.</summary>
            <remarks>This is not OpenPGP compliant. It is always a good idea to disallow the deletion of Self-Signatures.</remarks>
        </member>
        <member name="F:Libgpgme.PgpDeleteSignatureOptions.SelectedSignatures">
            <summary>The (key-) signature(s) that shall be deleted.</summary>
            <remarks>The array should contain the numbers of all (key-) signatures and/or revocation certificates that shall be deleted.</remarks>
        </member>
        <member name="F:Libgpgme.PgpDeleteSignatureOptions.SelectedUid">
            <summary>The user id from which the (key-) signature(s) shall be deleted.</summary>
            <remarks>A PGP key can contain several identities (user IDs). The first Uid (=1) is the primary user ID.</remarks>
        </member>
        <member name="T:Libgpgme.PgpExpirationOptions">
            <summary>A class that contains information for the key expiration operation on PGP keys.</summary>
            <remarks />
        </member>
        <member name="C:Libgpgme.PgpExpirationOptions">
            <summary>Creates a new instance.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.PgpExpirationOptions.ExpirationDate">
            <summary>The new expiration date for the selected subkey(s).</summary>
            <value>A <see cref="T:System.DateTime" />.</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
Depending on your timezone you might see the date 1970-01-01 UTC. This special date is used to mark a key to never expire.
You can unset the expiration date with the <see cref="M:Libgpgme.PgpExpirationOptions.MakeInfinitely()" /> method. 
</para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.PgpExpirationOptions.IsInfinitely">
            <summary>Indicates that the selected subkeys do not expire.</summary>
            <value>A <see cref="T:System.Boolean" />.</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
You can unset the expiration date with the <see cref="M:Libgpgme.PgpExpirationOptions.MakeInfinitely()" /> method.
  </para>
                </block>
            </remarks>
        </member>
        <member name="M:Libgpgme.PgpExpirationOptions.MakeInfinitely">
            <summary>Sets the selected subkey(s) to never expire.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.PgpExpirationOptions.SelectedSubkeys">
            <summary>The subkey(s) to which the new expiration date shall be applied.</summary>
            <remarks>The correct numbers can be determinated by enumerate the list of subkeys (<see cref="P:Libgpgme.Key.Subkeys" />) and counting the desired subkey(s).</remarks>
        </member>
        <member name="T:Libgpgme.PgpFeatureFlags">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpFeatureFlags.KeyserverModify">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.PgpFeatureFlags.MDC">
            <summary>To be added.</summary>
        </member>
        <member name="T:Libgpgme.PgpKey">
            <summary>An instance of this class represents an OpenPGP key.</summary>
            <remarks>This class has been inherited from <see cref="C:Libgpgme.Key" /> and provides additional methods and properties especially for OpenPGP keys.</remarks>
        </member>
        <member name="M:Libgpgme.PgpKey.AddSubkey(Libgpgme.Context,Libgpgme.PgpSubkeyOptions)">
            <param name="ctx">A <see cref="C:Libgpgme.Context" /> that is used to perform the operation.</param>
            <param name="options">A <see cref="C:Libgpgme.PgpSubkeyOptions" /> object containing the necessary information for the subkey generation.</param>
            <summary>Adds a new subkey to the PGP key.</summary>
            <remarks>The supplied context <paramref name="ctx" /> is locked during the editing operation. Make sure that the private key pair is available in the user's keystore.</remarks>
        </member>
        <member name="M:Libgpgme.PgpKey.ChangePassphrase(Libgpgme.Context,Libgpgme.PgpPassphraseOptions)">
            <param name="ctx">A <see cref="C:Libgpgme.Context" /> that is used to perform the operation.</param>
            <param name="options">A <see cref="C:Libgpgme.PgpPassphraseOptions" /> object that contains necessary information for the passphrase change operation.</param>
            <summary>Changes the passphrase of the private key.</summary>
            <remarks>The supplied context <paramref name="ctx" /> is locked during the editing operation. Make sure that the private key is available in the user's keystore.

<block subset="none" type="note"><para>
The context <paramref name="ctx" /> MUST NOT have a passphrase callback set. You can unset the passphrase callback by using <see cref="M:Libgpgme.Context.ClearPassphraseFunction()" />. Supplied passphrases in <paramref name="options" /> are ignored if GPG is configured to use gpg-agent (or any other GPG compatible pin-entry software).
  </para></block></remarks>
        </member>
        <member name="M:Libgpgme.PgpKey.DeleteSignature(Libgpgme.Context,Libgpgme.PgpDeleteSignatureOptions)">
            <param name="ctx">A <see cref="C:Libgpgme.Context" /> that is used to perform the operation.</param>
            <param name="options">A <see cref="C:Libgpgme.PgpDeleteSignatureOptions" /> object containing the necessary information for the signature deletion operation.</param>
            <summary>Deletes a key signature from a user id.</summary>
            <remarks>The supplied context <paramref name="ctx" /> is locked during the editing operation.</remarks>
        </member>
        <member name="M:Libgpgme.PgpKey.Disable(Libgpgme.Context)">
            <param name="ctx">A <see cref="C:Libgpgme.Context" /> that is used to perform the operation.</param>
            <summary>Disables a key.</summary>
            <remarks>The supplied context <paramref name="ctx" /> is locked during the editing operation.</remarks>
        </member>
        <member name="P:Libgpgme.PgpKey.EditSettings">
            <summary>General settings used during key edit operations.</summary>
            <value>A <see cref="C:Libgpgme.PgpKey+Settings" /> object.</value>
            <remarks />
        </member>
        <member name="M:Libgpgme.PgpKey.Enable(Libgpgme.Context)">
            <param name="ctx">A <see cref="C:Libgpgme.Context" /> that is used to perform the operation.</param>
            <summary>Enables a key.</summary>
            <remarks>The supplied context <paramref name="ctx" /> is locked during the editing operation.</remarks>
        </member>
        <member name="M:Libgpgme.PgpKey.KeyEditCallback(System.IntPtr,Libgpgme.KeyEditStatusCode,System.String,System.IO.Stream)">
            <param name="handle">To be added.</param>
            <param name="status">To be added.</param>
            <param name="args">To be added.</param>
            <param name="fd">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.PgpKey.RevokeSignature(Libgpgme.Context,Libgpgme.PgpRevokeSignatureOptions)">
            <param name="ctx">A <see cref="C:Libgpgme.Context" /> that is used to perform the operation.</param>
            <param name="options">A <see cref="C:Libgpgme.PgpRevokeSignatureOptions" /> object that contains necessary information for the (key-) signature deletion operation.</param>
            <summary>Creates a (key-) signature revocation certificate and adds it to the list of (key-) signatures.</summary>
            <remarks>The supplied context <paramref name="ctx" /> is locked during the editing operation. Make sure that the private keys are available for all (key-) signatures that shall be revoked.

<block subset="none" type="note"><para>
You need to specify the number(s) of the requested (key-) signature(s) in <paramref name="options" />. If you enumerate the list of (key-) signatures (<see cref="P:Libgpgme.UserId.Signatures" /> property) to count and identify the correct numbers - make sure that you DON'T count "revocation" signatures/certificates. You can check this with the <see cref="P:Libgpgme.KeySignature.Revoked" /> property for each (key-) signature in the list. 
</para><para>
Example:


<example><code>
# gpg --edit-key 321FEDCBA
Command &gt; check
uid  Mallory &lt;mallory@home.internal&gt;
rev!        ABCDEF123 2009-08-01  Alice &lt;alice@home.internal&gt;
rev!        ABCDEF123 2009-08-02  Alice &lt;alice@home.internal&gt;
sig!3        321FEDCBA 2009-08-01  [self-signature]
sig!        ABCDEF123 2009-08-01  Alice &lt;alice@home.internal&gt;
  </code>
There are four entries in this example list of (key-) signatures. The first two are "revocation signatures". That means the self-signature starts with number "1" and Alice's (key-)signature follows with number "2". (In this example, Alice created two revocation signatures/certificates. She created the first one on August 1st and the second one on August 2nd.)
</example></para></block></remarks>
        </member>
        <member name="M:Libgpgme.PgpKey.SetExpirationDate(Libgpgme.Context,Libgpgme.PgpExpirationOptions)">
            <param name="ctx">A <see cref="C:Libgpgme.Context" /> that is used to perform the operation.</param>
            <param name="options">A <see cref="C:Libgpgme.PgpExpirationOptions" /> object containing the necessary expiration information.</param>
            <summary>Sets a new expiration date for one or more subkeys.</summary>
            <remarks>The supplied context <paramref name="ctx" /> is locked during the editing operation.</remarks>
        </member>
        <member name="M:Libgpgme.PgpKey.SetOwnerTrust(Libgpgme.Context,Libgpgme.PgpOwnerTrust)">
            <param name="ctx">A <see cref="C:Libgpgme.Context" /> that is used to perform the operation.</param>
            <param name="trust">The new <see cref="T:Libgpgme.PgpOwnerTrust" />.</param>
            <summary>Sets the owner trust for this particular PGP key.</summary>
            <remarks>The supplied context <paramref name="ctx" /> is locked during the editing operation.</remarks>
        </member>
        <member name="M:Libgpgme.PgpKey.Sign(Libgpgme.Context,Libgpgme.PgpSignatureOptions)">
            <param name="ctx">A <see cref="C:Libgpgme.Context" /> that is used to perform the operation.</param>
            <param name="options">To be added.</param>
            <summary>To be added.</summary>
            <remarks>The supplied context <paramref name="ctx" /> is locked during the editing operation.</remarks>
        </member>
        <member name="T:Libgpgme.PgpKey+PassphraseSettings">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.PgpKey+PassphraseSettings">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpKey+PassphraseSettings.Passphrase">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpKey+PassphraseSettings.PassphraseFunction">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.PgpKey+Settings">
            <summary>A class that contains general settings used during key edit operations.</summary>
            <remarks>At the moment the user can specify a passphrase or passphrase callback method that is used by various key edit operations.
<block subset="none" type="note"><para>
This DOES NOT work if GPG is configured to use an agent (or pin-entry software) to acquire the user's passphrase. It is highly recommended to use GPG with a passphrase agent.
  </para></block></remarks>
        </member>
        <member name="P:Libgpgme.PgpKey+Settings.Passphrase">
            <summary>A passphrase provided by the user.</summary>
            <value>An array of <see cref="T:System.Char" />s.</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
Make sure that you overwrite (wipe) the user's passphrase in memory. You should not use the <see cref="M:System.String.ToArray()" /> method to convert a user supplied string if you do not hold any further reference to it.
  </para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.PgpKey+Settings.PassphraseFunction">
            <summary>A callback method that is called if the GPGME backend would need a passphrase.</summary>
            <value>A <see cref="T:Libgpgme.PassphraseDelegate" />.</value>
            <remarks />
        </member>
        <member name="T:Libgpgme.PgpOwnerTrust">
            <summary>A type that is used to specify the PGP owner trust level.</summary>
            <remarks>Decide how far we trust this user to correctly verify other users' keys (by looking at passports, checking fingerprints from different sources, etc.).
</remarks>
        </member>
        <member name="F:Libgpgme.PgpOwnerTrust.Full">
            <summary>Fully trust this key.</summary>
        </member>
        <member name="F:Libgpgme.PgpOwnerTrust.Marginal">
            <summary>Trust this key marginally.</summary>
        </member>
        <member name="F:Libgpgme.PgpOwnerTrust.Never">
            <summary>Do NOT trust this key.</summary>
        </member>
        <member name="F:Libgpgme.PgpOwnerTrust.Ultimate">
            <summary>Ultimately trust this key.</summary>
        </member>
        <member name="F:Libgpgme.PgpOwnerTrust.Undefined">
            <summary>Undefined.</summary>
        </member>
        <member name="T:Libgpgme.PgpPassphraseOptions">
            <summary>A class that contains information for the passphrase change operation.</summary>
            <remarks />
        </member>
        <member name="C:Libgpgme.PgpPassphraseOptions">
            <summary>Creates a new instance.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.PgpPassphraseOptions.EmptyOkay">
            <summary>Indicates that empty passphrases are allowed.</summary>
            <remarks>Is <see langword="false" /> by default.</remarks>
        </member>
        <member name="F:Libgpgme.PgpPassphraseOptions.NewPassphrase">
            <summary>The key's new passphrase.</summary>
            <remarks>Will be ignored if GPG is configured to use gpg-agent (or any other GPG compatible pin-entry software).
<block subset="none" type="note"><para>
Make sure that you overwrite (wipe) the user's passphrase in memory. The callback will NOT wipe the char array after usage.
  </para></block></remarks>
        </member>
        <member name="F:Libgpgme.PgpPassphraseOptions.NewPassphraseCallback">
            <summary>A callback method that is called when the GPGME backend requires the key's new passphrase.</summary>
            <remarks>Will be ignored if GPG is configured to use gpg-agent (or any other GPG compatible pin-entry software).</remarks>
        </member>
        <member name="F:Libgpgme.PgpPassphraseOptions.OldPassphrase">
            <summary>The key's old passphrase.</summary>
            <remarks>Will be ignored if GPG is configured to use gpg-agent (or any other GPG compatible pin-entry software).
<block subset="none" type="note"><para>
Make sure that you overwrite (wipe) the user's passphrase in memory. The callback will NOT wipe the char array after usage.
  </para></block></remarks>
        </member>
        <member name="F:Libgpgme.PgpPassphraseOptions.OldPassphraseCallback">
            <summary>A callback method that is called when the GPGME backend requires the key's old passphrase.</summary>
            <remarks>Will be ignored if GPG is configured to use gpg-agent (or any other GPG compatible pin-entry software).</remarks>
        </member>
        <member name="T:Libgpgme.PgpRevokeSignatureOptions">
            <summary>A class that contains information for the (key-) signature revocation operation.</summary>
            <remarks />
        </member>
        <member name="C:Libgpgme.PgpRevokeSignatureOptions">
            <summary>Creates a new instance.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.PgpRevokeSignatureOptions.ReasonCode">
            <summary>The reason for the (key-) signature revocation.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.PgpRevokeSignatureOptions.ReasonText">
            <summary>A reason text for the (key-) signature revocation.</summary>
            <value>A <see cref="T:System.String" />.</value>
            <remarks />
        </member>
        <member name="F:Libgpgme.PgpRevokeSignatureOptions.SelectedSignatures">
            <summary>The (key-) signatures that shall be revoked.</summary>
            <remarks>
                <block subset="none" type="note">
                    <para>
You need to specify an (<see langword="int" />) array containing the numbers of all (key-) signatures that shall be revoked. If you enumerate the list of (key-) signatures (<see cref="P:Libgpgme.UserId.Signatures" /> property) to count and identify the correct numbers - make sure that you DON'T count "revocation" signatures/certificates. You can check this with the <see cref="P:Libgpgme.KeySignature.Revoked" /> property for each (key-) signature in the list. 
</para>
                    <para>
Example:


<example><code>
# gpg --edit-key 321FEDCBA
Command &gt; check
uid  Mallory &lt;mallory@home.internal&gt;
rev!        ABCDEF123 2009-08-01  Alice &lt;alice@home.internal&gt;
rev!        ABCDEF123 2009-08-02  Alice &lt;alice@home.internal&gt;
sig!3        321FEDCBA 2009-08-01  [self-signature]
sig!        ABCDEF123 2009-08-01  Alice &lt;alice@home.internal&gt;
  </code>
There are four entries in this example list of (key-) signatures. The first two are "revocation signatures". That means the self-signature starts with number "1" and Alice's (key-)signature follows with number "2". (In this example, Alice created two revocation signatures/certificates. She created the first one on August 1st and the second one on August 2nd.)
</example></para>
                </block>
            </remarks>
        </member>
        <member name="F:Libgpgme.PgpRevokeSignatureOptions.SelectedUid">
            <summary>The user ID from which (key-) signatures shall be revoked.</summary>
            <remarks>A PGP key can contain several identities (user IDs). The first Uid (=1) is the primary user ID.</remarks>
        </member>
        <member name="T:Libgpgme.PgpRevokeSignatureReasonCode">
            <summary>The reason code for a (key-) signature revocation.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.PgpRevokeSignatureReasonCode.NoReason">
            <summary>No reason specified.</summary>
        </member>
        <member name="F:Libgpgme.PgpRevokeSignatureReasonCode.UidNoLongerValid">
            <summary>The user ID is not longer valid.</summary>
        </member>
        <member name="T:Libgpgme.PgpSignatureClass">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpSignatureClass.Casual">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.PgpSignatureClass.Generic">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.PgpSignatureClass.Persona">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.PgpSignatureClass.Positive">
            <summary>To be added.</summary>
        </member>
        <member name="T:Libgpgme.PgpSignatureOptions">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.PgpSignatureOptions">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpSignatureOptions.Class">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpSignatureOptions.ExpirationDate">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.PgpSignatureOptions.IsInfinitely">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpSignatureOptions.LocalPromoteOkay">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpSignatureOptions.SelectedUids">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.PgpSignatureOptions.TrustDepth">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpSignatureOptions.TrustLevel">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpSignatureOptions.TrustRegexp">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpSignatureOptions.Type">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.PgpSignatureTrustLevel">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpSignatureTrustLevel.Full">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.PgpSignatureTrustLevel.Marginal">
            <summary>To be added.</summary>
        </member>
        <member name="T:Libgpgme.PgpSignatureType">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpSignatureType.NonExportable">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.PgpSignatureType.NonRevocable">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.PgpSignatureType.Normal">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.PgpSignatureType.Trust">
            <summary>To be added.</summary>
        </member>
        <member name="T:Libgpgme.PgpSubkeyAlgorithm">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PgpSubkeyAlgorithm.DSASignOnly">
            <summary>This value indicates DSA, the Digital Signature Algorithm (signature only).</summary>
        </member>
        <member name="F:Libgpgme.PgpSubkeyAlgorithm.DSAUseCapabilities">
            <summary>This value indicates DSA, the Digital Signature Algorithm. 

<block subset="none" type="note"><para>
This value is only available if GPG is configured to use the Expert-mode ("expert" in gpg.conf).
  </para></block></summary>
        </member>
        <member name="F:Libgpgme.PgpSubkeyAlgorithm.ELGEncryptOnly">
            <summary>This value indicates ElGamal (encryption only). </summary>
        </member>
        <member name="F:Libgpgme.PgpSubkeyAlgorithm.RSAEncryptOnly">
            <summary>This value indicates the RSA (Rivest, Shamir, Adleman) algorithm for encryption and decryption only.</summary>
        </member>
        <member name="F:Libgpgme.PgpSubkeyAlgorithm.RSASignOnly">
            <summary>This value indicates the RSA (Rivest, Shamir, Adleman) algorithm for signing and verification only.</summary>
        </member>
        <member name="F:Libgpgme.PgpSubkeyAlgorithm.RSAUseCapabilities">
            <summary>This value indicates the RSA (Rivest, Shamir, Adleman) algorithm.
<block subset="none" type="note"><para>
This value is only available if GPG is configured to use the Expert-mode ("expert" in gpg.conf).
  </para></block></summary>
        </member>
        <member name="T:Libgpgme.PgpSubkeyOptions">
            <summary>A class that contains information about a new subkey.</summary>
            <remarks />
        </member>
        <member name="C:Libgpgme.PgpSubkeyOptions">
            <summary>Creates a new instance.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.PgpSubkeyOptions.Algorithm">
            <summary>The public key algorithm to be used for the new subkey.</summary>
            <remarks>
                <block subset="none" type="note">
                    <para>
You can use the <see cref="M:Libgpgme.PgpSubkeyOptions.SetAlgorithm(Libgpgme.KeyAlgorithm)" /> method as well. Make sure to set proper key capabilities by using the <see cref="P:Libgpgme.PgpSubkeyOptions.Capability" /> property.
  </para>
                </block>
            </remarks>
        </member>
        <member name="F:Libgpgme.PgpSubkeyOptions.Capability">
            <summary>The key capabilities of the new subkey.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.PgpSubkeyOptions.ExpirationDate">
            <summary>The expiration date of the new subkey.</summary>
            <value>A <see cref="T:System.DateTime" />.</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
Depending on your timezone you might see the date 1970-01-01 UTC. This special date is used to mark a key to never expire.
You can unset the expiration date with the <see cref="M:Libgpgme.PgpSubkeyOptions.MakeInfinitely()" /> method. 
</para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.PgpSubkeyOptions.IsInfinitely">
            <summary>Indicates that the new subkey does not expire.</summary>
            <value>A <see cref="T:System.Boolean" />.</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
You can unset the expiration date with the <see cref="M:Libgpgme.PgpSubkeyOptions.MakeInfinitely()" /> method.
  </para>
                </block>
            </remarks>
        </member>
        <member name="F:Libgpgme.PgpSubkeyOptions.KEY_LENGTH_1024">
            <summary>1024 bits key size.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.PgpSubkeyOptions.KEY_LENGTH_2048">
            <summary>2048 bits key size.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.PgpSubkeyOptions.KEY_LENGTH_4096">
            <summary>4096 bits key size.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.PgpSubkeyOptions.KeyLength">
            <summary>The new subkey's length in bits.</summary>
            <value>A <see cref="T:System.Int32" />.</value>
            <remarks>
                <para>
You can use the following constant values:
</para>
                <list type="table">
                    <listheader>
                        <term>Constant</term>
                        <description>Description</description>
                    </listheader>
                    <item>
                        <term>
                            <see cref="F:Libgpgme.PgpSubkeyOptions.KEY_LENGTH_1024" />
                        </term>
                        <description>for 1024 bits key length</description>
                    </item>
                    <item>
                        <term>
                            <see cref="F:Libgpgme.PgpSubkeyOptions.KEY_LENGTH_2048" />
                        </term>
                        <description>for 2048 bits key length</description>
                    </item>
                    <item>
                        <term>
                            <see cref="F:Libgpgme.PgpSubkeyOptions.KEY_LENGTH_4096" />
                        </term>
                        <description>for 4096 bits key length</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:Libgpgme.PgpSubkeyOptions.MakeInfinitely">
            <summary>Sets the new subkey to never expire.</summary>
            <remarks />
        </member>
        <member name="M:Libgpgme.PgpSubkeyOptions.SetAlgorithm(Libgpgme.KeyAlgorithm)">
            <param name="algo">A <see cref="T:Libgpgme.KeyAlgorithm" />.</param>
            <summary>Sets the public key algorithm to be used for the new subkey.</summary>
            <remarks>
                <block subset="none" type="note">
                    <para>
You can use the <see cref="P:Libgpgme.PgpSubkeyOptions.Algorithm" /> property as well. Make sure to set proper key capabilities by using the <see cref="P:Libgpgme.PgpSubkeyOptions.Capability" /> property.
  </para>
                </block>
            </remarks>
        </member>
        <member name="T:Libgpgme.PkaStatus">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.PkaStatus.Bad">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.PkaStatus.NotAvailable">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.PkaStatus.Okay">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.PkaStatus.RFU">
            <summary>To be added.</summary>
        </member>
        <member name="T:Libgpgme.Protocol">
            <summary>Specifies the set of possible protocol values that are supported by GPGME.</summary>
            <remarks>GPGME supports several cryptographic protocols, however, it does not implement them.  Rather it uses backends (also called engines) which
implement the protocol.  GPGME uses inter-process communication to pass data back and forth between the application and the backend, but the details of the communication protocol and invocation of the backend is completely hidden by the interface.  All complexity is handled by
GPGME.  Where an exchange of information between the application and the backend is necessary, GPGME provides the necessary callback function hooks and further interfaces.
</remarks>
        </member>
        <member name="F:Libgpgme.Protocol.CMS">
            <summary>The Cryptographic Message Syntax.</summary>
        </member>
        <member name="F:Libgpgme.Protocol.GPGConf">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.Protocol.OpenPGP">
            <summary>The OpenPGP protocol.</summary>
        </member>
        <member name="F:Libgpgme.Protocol.Unknown">
            <summary>Reserved for future extension.  You may use this to indicate that the used protocol is not known to the application. Currently, GPGME does not accept this value in any operation, though, except for <see cref="M:Libgpgme.Gpgme.GetProtocolName(Libgpgme.Protocol)" />.
</summary>
        </member>
        <member name="T:Libgpgme.Recipient">
            <summary>Information about a recipient of an encrypted text.</summary>
            <remarks>
                <para>
This is an object used to store information about the recipients of an encrypted text which is decrypted in a decryption operation. 
</para>
You can enumerate the particular recipients through the <see cref="P:Libgpgme.Recipient.Next" /> property or by using the <see cref="M:Libgpgme.Recipient.GetEnumerator()" /> method.
</remarks>
        </member>
        <member name="M:Libgpgme.Recipient.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Recipient.KeyAlgorithm">
            <summary>The public key algorithm used in the encryption.</summary>
            <value>A <see cref="T:Libgpgme.KeyAlgorithm" />.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Recipient.KeyId">
            <summary>The key ID of a recipient.</summary>
            <value>A <see cref="T:System.String" /> containing the hexadecimal key ID.</value>
            <remarks>This is the key ID of the key (in hexadecimal digits) used as recipient.
</remarks>
        </member>
        <member name="P:Libgpgme.Recipient.Next">
            <summary>A reference to the next recipient.</summary>
            <value>A reference to the next <see cref="C:Libgpgme.Recipient" /> object in the linked list, or <see langword="null" /> if this is the last element.
</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Recipient.Status">
            <summary>Error number.</summary>
            <value>An error number with the error code 17 if the secret key for this recipient is not available, and 0 otherwise.</value>
            <remarks />
        </member>
        <member name="M:Libgpgme.Recipient.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.Signature">
            <summary>Information about a signature.
</summary>
            <remarks>
                <para>
Used to store a part of the result of a verification operation.
</para>
The <see cref="C:Libgpgme.Signature" /> class is implemented as linked list. You can use the <see cref="P:Libgpgme.Signature.Next" /> property or the <see cref="M:Libgpgme.Signature.GetEnumerator()" /> method to enumerate all signatures.
</remarks>
        </member>
        <member name="P:Libgpgme.Signature.ChainModel">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.ExpTimestamp">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.ExpTimestampUTC">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.Fingerprint">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.Signature.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.HashAlgorithm">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.Next">
            <summary>A reference to the next signature object.</summary>
            <value>A reference to the next signature object in the linked list, or <see langword="null" /> if this is the last element.
</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Signature.Notations">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.PKAAddress">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.PKATrust">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.PubkeyAlgorithm">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.Status">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.Summary">
            <summary>A summary of the signature status.</summary>
            <value>A <see cref="T:Libgpgme.SignatureSummary" /> bit vector.</value>
            <remarks>This is a bit vector giving a summary of the signature status. It provides an easy interface to a defined semantic of the signature status. Checking just one bit is sufficient to see whether a signature is valid without any restrictions.
</remarks>
        </member>
        <member name="M:Libgpgme.Signature.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.Timestamp">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.TimestampUTC">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.Validity">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.ValidityReason">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Signature.WrongKeyUsage">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.SignatureMode">
            <summary>Used to specify the desired type of a signature.</summary>
            <remarks>Used by <see cref="M:Libgpgme.Context.Sign(Libgpgme.GpgmeData,Libgpgme.GpgmeData,Libgpgme.SignatureMode)" /> and <see cref="M:Libgpgme.Context.EncryptAndSign(Libgpgme.Key[],Libgpgme.EncryptFlags,Libgpgme.GpgmeData,Libgpgme.GpgmeData)" />.</remarks>
        </member>
        <member name="F:Libgpgme.SignatureMode.Clear">
            <summary>A clear text signature is made. The ASCII armor (<see cref="P:Libgpgme.Context.Armor" />) and text mode (<see cref="P:Libgpgme.Context.TextMode" />) settings of the context are ignored.
</summary>
        </member>
        <member name="F:Libgpgme.SignatureMode.Detach">
            <summary>A detached signature is made.</summary>
        </member>
        <member name="F:Libgpgme.SignatureMode.Normal">
            <summary>A normal signature is made, the output includes the plaintext and the signature.
</summary>
        </member>
        <member name="T:Libgpgme.SignatureNotation">
            <summary>A class that is used to store information about notation data and policy URLs.</summary>
            <remarks>This class is implemented as linked list. You can enumerate all items by using the <see cref="P:Libgpgme.SignatureNotation.Next" /> property or the <see cref="M:Libgpgme.SignatureNotation.GetEnumerator()" /> method.</remarks>
        </member>
        <member name="P:Libgpgme.SignatureNotation.Critical">
            <summary>Indicates that the Critical-Usage bit is set. </summary>
            <value>A <see cref="T:System.Boolean" />.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.SignatureNotation.Flags">
            <summary>The signature notation data flags.</summary>
            <value>A <see cref="T:Libgpgme.SignatureNotationFlags" /> value.</value>
            <remarks />
        </member>
        <member name="M:Libgpgme.SignatureNotation.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.SignatureNotation.HumanReadable">
            <summary>Indicates that the string is in human-readable form.</summary>
            <value>A <see cref="T:System.Boolean" />.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.SignatureNotation.Name">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.SignatureNotation.Next">
            <summary>The next signature notation data object in the linked list.</summary>
            <value>The next <see cref="C:Libgpgme.SignatureNotation" /> object in the linked list.</value>
            <remarks>This class is implemented as linked list. You can enumerate all items by using the <see cref="P:Libgpgme.SignatureNotation.Next" /> property or the <see cref="M:Libgpgme.SignatureNotation.GetEnumerator()" /> method.</remarks>
        </member>
        <member name="M:Libgpgme.SignatureNotation.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.SignatureNotation.Value">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.SignatureNotationFlags">
            <summary>A type for signature notation flags.</summary>
            <remarks>The flag <see cref="P:Libgpgme.SignatureNotationFlags.HumanReadable" /> is implied (non-human-readable notation data is currently not supported). The strings must be in UTF-8 encoding (will be automatically transformed when using <see cref="T:System.String" />).</remarks>
        </member>
        <member name="F:Libgpgme.SignatureNotationFlags.Critical">
            <summary>The Critical-Usage bit is set.</summary>
        </member>
        <member name="F:Libgpgme.SignatureNotationFlags.HumanReadable">
            <summary>The string is in human-readable form.</summary>
        </member>
        <member name="T:Libgpgme.SignatureResult">
            <summary>Contains information about the signature process.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.SignatureResult.InvalidSigners">
            <summary>Signer keys that require unsupported algorithms or an invalid passphrase has been supplied.</summary>
            <value>Invalid signer keys. Is <see langword="null" /> if there were no invalid signers.</value>
            <remarks>Contains a linked list with information about all invalid keys for which a signature could not be created.</remarks>
        </member>
        <member name="P:Libgpgme.SignatureResult.Signatures">
            <summary>Contains information about all signatures created.</summary>
            <value>Contains a linked list with information about all signatures created. Is <see langword="null" /> if no signature has been created.</value>
            <remarks />
        </member>
        <member name="T:Libgpgme.SignatureSummary">
            <summary>A type that is giving information about the signature status.</summary>
            <remarks>This type is used as a bit vector giving a summary of the signature status.  It provides an easy interface to a defined semantic of the signature status. Checking just one bit is sufficient to see whether a signature is valid without any restrictions.
</remarks>
        </member>
        <member name="F:Libgpgme.SignatureSummary.BadPolicy">
            <summary>A policy requirement was not met.</summary>
        </member>
        <member name="F:Libgpgme.SignatureSummary.CRLMissing">
            <summary>The CRL (or an equivalent mechanism) is not available.</summary>
        </member>
        <member name="F:Libgpgme.SignatureSummary.CRLTooOld">
            <summary>Available CRL is too old.</summary>
        </member>
        <member name="F:Libgpgme.SignatureSummary.Green">
            <summary>The signature is good but one might want to display some extra information.  Check the other bits.
</summary>
        </member>
        <member name="F:Libgpgme.SignatureSummary.KeyExpired">
            <summary>The key or one of the certificates has expired. It is probably a good idea to display the date of the expiration.</summary>
        </member>
        <member name="F:Libgpgme.SignatureSummary.KeyMissing">
            <summary>Can't verify due to a missing key or certificate.</summary>
        </member>
        <member name="F:Libgpgme.SignatureSummary.KeyRevoked">
            <summary>The key or at least one certificate has been revoked.</summary>
        </member>
        <member name="F:Libgpgme.SignatureSummary.Red">
            <summary>The signature is bad. It might be useful to check other bits and display more information, i.e. a revoked certificate might not render a signature invalid when the message was received prior to the cause for the revocation.
</summary>
        </member>
        <member name="F:Libgpgme.SignatureSummary.SignatureExpired">
            <summary>The signature has expired.</summary>
        </member>
        <member name="F:Libgpgme.SignatureSummary.SysError">
            <summary>A system error occured.</summary>
        </member>
        <member name="F:Libgpgme.SignatureSummary.Valid">
            <summary>The signature is fully valid.</summary>
        </member>
        <member name="T:Libgpgme.Subkey">
            <summary>A class that contains information about a sub key.</summary>
            <remarks>Sub keys are one component of a <see cref="C:Libgpgme.Key" /> object. In fact, subkeys are those parts that contains the real information about the individual cryptographic keys that belong to the same key object. One <see cref="C:Libgpgme.Key" /> can contain several subkeys. The first subkey in the linked list is also called the primary key. You can enumerate all subkeys by using the <see cref="P:Libgpgme.Subkey.Next" /> property or the <see cref="M:Libgpgme.Subkey.GetEnumerator()" /> method.
</remarks>
        </member>
        <member name="P:Libgpgme.Subkey.CanAuthenticate">
            <summary>Indicates that the subkey can be used for authentication.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the subkey can be used for authentication.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Subkey.CanCertify">
            <summary>Indicates that the subkey can be used to create key certificates.</summary>
            <value>
                <see cref="T:System.Boolean" /> that is <see langword="true" /> if the subkey can be used to create key certificates.
</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Subkey.CanEncrypt">
            <summary>Indicates that the subkey can be used for encryption.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the subkey can be used for encryption.
</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Subkey.CanSign">
            <summary>Indicates that the subkey can be used to create data signatures.</summary>
            <value>
                <see cref="T:System.Boolean" /> that is <see langword="true" /> if the subkey can be used to create data signatures.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Subkey.Disabled">
            <summary>Indicates that the subkey has been disabled.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the subkey is disabled.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Subkey.Expired">
            <summary>Indicates that the subkey is expired.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the subkey is expired.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Subkey.Expires">
            <summary>The expiration timestamp of the subkey.</summary>
            <value>A <see cref="T:System.DateTime" /> containing the expiration timestamp of the subkey.</value>
            <remarks>Always check the <see cref="P:Libgpgme.Subkey.IsInfinitely" /> property in order to find out whether the subkey can expire. If the key cannot expire, <see cref="P:Libgpgme.Subkey.Expires" /> contains an invalid value (Depending on your timezone you might see the date 1970-01-01 UTC).</remarks>
        </member>
        <member name="P:Libgpgme.Subkey.ExpiresUTC">
            <summary>The expiration timestamp of the subkey in UTC.</summary>
            <value>A <see cref="T:System.DateTime" /> containing the expiration timestamp of the subkey.</value>
            <remarks>Always check the <see cref="P:Libgpgme.Subkey.IsInfinitely" /> property in order to find out whether the subkey can expire. If the key cannot expire, <see cref="P:Libgpgme.Subkey.Expires" /> contains an invalid value (Depending on your timezone you might see the date 1970-01-01 UTC).</remarks>
        </member>
        <member name="P:Libgpgme.Subkey.Fingerprint">
            <summary>This is the fingerprint of the subkey.</summary>
            <value>A <see cref="T:System.String" /> containing the fingerprint of the subkey in hexadecimal digits. <see langword="null" /> if not available.
</value>
            <remarks />
        </member>
        <member name="M:Libgpgme.Subkey.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Subkey.Invalid">
            <summary>Indicates that a subkey is invalid.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the subkey is invalid.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Subkey.IsInfinitely">
            <summary>Indicates that a key does not expire.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the key does not expire.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Subkey.IsQualified">
            <summary>Indicates that the subkey can be used for qualified signatures.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the subkey can be used for qualified signatures.
</value>
            <remarks>Qualified signatures according to local government regulations.</remarks>
        </member>
        <member name="P:Libgpgme.Subkey.KeyId">
            <summary>The key ID of the subkey.</summary>
            <value>A <see cref="T:System.String" /> containing the key ID of the subkey in hexadecimal digits.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Subkey.Length">
            <summary>The length of the subkey.</summary>
            <value>A <see cref="T:System.Int64" /> containing the length of the subkey in bits.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Subkey.Next">
            <summary>The next Subkey object in the linked list.</summary>
            <value>The next <see cref="C:Libgpgme.Subkey" /> object in the linked list, or <see langword="null" /> if this is the last element.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Subkey.PubkeyAlgorithm">
            <summary>The public key algorithm supported by this subkey.</summary>
            <value>A <see cref="T:Libgpgme.KeyAlgorithm" />.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Subkey.Revoked">
            <summary>Indicates that the subkey has been revoked.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the subkey is revoked.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.Subkey.Secret">
            <summary>Indicates that the subkey is a secret key. </summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the subkey is a secret key. </value>
            <remarks>
                <block subset="none" type="note">
                    <para>
It will be <see langword="false" /> if the key is actually a stub key; i.e. a secret key operation is currently not possible (offline-key).
  </para>
                </block>
            </remarks>
        </member>
        <member name="M:Libgpgme.Subkey.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.Subkey.Timestamp">
            <summary>The creation timestamp of the subkey.</summary>
            <value>A <see cref="T:System.DateTime" /> containing the creation timestamp of the subkey.
</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
A <see cref="C:Libgpgme.InvalidTimestampException" /> will be raised if the timestamp is invalid. A <see cref="C:Libgpgme.TimestampNotAvailableException" /> will be raised if the timestamp is not available.
  </para>
                </block>
            </remarks>
        </member>
        <member name="P:Libgpgme.Subkey.TimestampUTC">
            <summary>The creation timestamp of the subkey in UTC.</summary>
            <value>A <see cref="T:System.DateTime" /> containing the creation timestamp of the subkey in UTC.
</value>
            <remarks>
                <block subset="none" type="note">
                    <para>
A <see cref="C:Libgpgme.InvalidTimestampException" /> will be raised if the timestamp is invalid. A <see cref="C:Libgpgme.TimestampNotAvailableException" /> will be raised if the timestamp is not available.
</para>
                </block>
            </remarks>
        </member>
        <member name="T:Libgpgme.TimestampNotAvailableException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.TimestampNotAvailableException">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Libgpgme.TimestampNotAvailableException(System.String)">
            <param name="message">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.TrustItem">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.TrustItem.Finalize">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.TrustItem.KeyId">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.TrustItem.Level">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.TrustItem.Name">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.TrustItem.OwnerTrust">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.TrustItem.Type">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.TrustItem.Validity">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Libgpgme.TrustItemType">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Libgpgme.TrustItemType.Key">
            <summary>To be added.</summary>
        </member>
        <member name="F:Libgpgme.TrustItemType.UserId">
            <summary>To be added.</summary>
        </member>
        <member name="T:Libgpgme.UserId">
            <summary>A user ID is a component of a <see cref="C:Libgpgme.Key" /> object.</summary>
            <remarks>
                <para>
One key can have many user IDs. The first one in the list is the main (or primary) user ID.
</para>
                <para>
The UserID object is implemented as linked list. You can enumerate all user IDs by using the <see cref="P:Libgpgme.UserId.Next" /> property or the <see cref="M:Libgpgme.UserId.GetEnumerator()" /> method.
</para>
            </remarks>
        </member>
        <member name="P:Libgpgme.UserId.Comment">
            <summary>The comment component of Uid, if available.</summary>
            <value>A <see cref="T:System.String" /> containing the comment component of <see cref="P:Libgpgme.UserId.Uid" />, if available.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.UserId.Email">
            <summary>The email component of Uid, if available.
</summary>
            <value>A <see cref="T:System.String" /> containing the email component of <see cref="P:Libgpgme.UserId.Uid" />, if available.</value>
            <remarks />
        </member>
        <member name="M:Libgpgme.UserId.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.UserId.Invalid">
            <summary>Indicates that the user ID is invalid.
</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the user ID is invalid.
</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.UserId.Name">
            <summary>This is the name component of Uid, if available.</summary>
            <value>A <see cref="T:System.String" /> containing the name component of <see cref="P:Libgpgme.UserId.Uid" />, if available.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.UserId.Next">
            <summary>The next user ID object in the linked list.</summary>
            <value>A <see cref="C:Libgpgme.UserId" /> object or <see langword="null" /> if this is the last element.</value>
            <remarks>
                <para>
The UserID object is implemented as linked list. You can enumerate all user IDs by using the <see cref="P:Libgpgme.UserId.Next" /> property or the <see cref="M:Libgpgme.UserId.GetEnumerator()" /> method.
</para>
            </remarks>
        </member>
        <member name="P:Libgpgme.UserId.Revoked">
            <summary>Indicates that the user ID is revoked.</summary>
            <value>A <see cref="T:System.Boolean" /> that is <see langword="true" /> if the user ID is revoked.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.UserId.Signatures">
            <summary>A linked list with the signatures on this user ID.
</summary>
            <value>The first <see cref="C:Libgpgme.KeySignature" /> on this user ID. <see langword="null" /> if no information is available.</value>
            <remarks>
                <para>
Key signatures are one component of a <see cref="C:Libgpgme.Key" /> object, and validate user IDs (<see cref="C:Libgpgme.UserId" />) on the key. You can enumerate all key signatures by using the <see cref="P:Libgpgme.KeySignature.Next" /> property or the <see cref="M:Libgpgme.KeySignature.GetEnumerator()" /> method.
</para>
                <block subset="none" type="note">
                    <para>
The signatures on a key are only available if the key was retrieved via a listing operation with the <see cref="F:Libgpgme.KeylistMode.Signatures" /> flag enabled (see <see cref="P:Libgpgme.Context.KeylistMode" />), because it can be expensive to retrieve all signatures of a key.
</para>
                    <para>
The signature notations on a key signature are only available if the key was retrieved via a listing operation with the <see cref="F:Libgpgme.KeylistMode.SignatureNotations" /> flag enabled (see <see cref="P:Libgpgme.Context.KeylistMode" />), because it can be expensive to retrieve all signature notations.
  </para>
                </block>
            </remarks>
        </member>
        <member name="M:Libgpgme.UserId.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Libgpgme.UserId.ToString">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Libgpgme.UserId.Uid">
            <summary>The user ID string.</summary>
            <value>A <see cref="T:System.String" />.</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.UserId.Validity">
            <summary>Specifies the validity of the user ID.</summary>
            <value>A <see cref="T:Libgpgme.Validity" /> specifing the validity of the user ID.
</value>
            <remarks />
        </member>
        <member name="T:Libgpgme.Validity">
            <summary>A type that is used to specify the validity of a user ID in a key.</summary>
            <remarks />
        </member>
        <member name="F:Libgpgme.Validity.Full">
            <summary>The user ID is fully valid.  The string representation of this validity is "f".</summary>
        </member>
        <member name="F:Libgpgme.Validity.Marginal">
            <summary>The user ID is marginally valid.  The string representation of this validity is "m".</summary>
        </member>
        <member name="F:Libgpgme.Validity.Never">
            <summary>The user ID is never valid.  The string representation of this validity is "n".</summary>
        </member>
        <member name="F:Libgpgme.Validity.Ultimate">
            <summary>The user ID is ultimately valid.  The string representation of this validity is "u".</summary>
        </member>
        <member name="F:Libgpgme.Validity.Undefined">
            <summary>The validity of the user ID is undefined.  The string representation of this validity is "q".</summary>
        </member>
        <member name="F:Libgpgme.Validity.Unknown">
            <summary>The user ID is of unknown validity.  The string representation of this validity is "?".</summary>
        </member>
        <member name="T:Libgpgme.VerificationResult">
            <summary>A class that contains information about a verification result.</summary>
            <remarks />
        </member>
        <member name="P:Libgpgme.VerificationResult.FileName">
            <summary>The filename of the original plaintext message.</summary>
            <value>A <see cref="T:System.String" /> containing the filename of the original plaintext message file if it is known, <see langword="null" /> otherwise.
</value>
            <remarks />
        </member>
        <member name="P:Libgpgme.VerificationResult.Signature">
            <summary>Information about all signatures for which a verification was attempted.</summary>
            <value>A <see cref="C:Libgpgme.Signature" /> object. <see langword="null" /> if the message was not signed.</value>
            <remarks>A linked list with information about all signatures for which a verification was attempted. You can use the <see cref="P:Libgpgme.Signature.Next" /> property or the <see cref="M:Libgpgme.Signature.GetEnumerator()" /> method to enumerate all signatures.
</remarks>
        </member>
        <member name="T:Libgpgme.X509Key">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
    </members>
</doc>
